<?xml version="1.0" encoding="UTF-8"?>
<Worksheet>
<Version major="18" minor="1"/>
<Label-Scheme value="2" prefix=""/>
<View-Properties presentation="false" autoexpanding_sections="true">
</View-Properties>
<MapleNet-Properties elisiondigitsbefore="100" labelling="true" indentamount="4" elisiontermsthreshold="10000" ansi="false" errorbreak="1" useclientjvm="true" echo="1" imaginaryunit="I" labelwidth="20" unitattributes="&quot;fontweight&quot; = &quot;bold&quot;" contextmenusize="automatic" plotdriver="opengl" elisiondigitsafter="100" plotoutput="terminal" helpbrowser="standard" rtablesize="10" elisiontermsbefore="100" elisiondigitsthreshold="10000" typesetting="extended" plotdevice="inline" verboseproc="1" showassumed="1" quiet="false" errorcursor="false" longdelim="true" plotoptions="" elisiontermsafter="100" screenwidth="79" preplot="" prettyprint="3" displayprecision="-1" screenpixelheight="768" warnlevel="3" screenheight="25" latexwidth="8.0" postplot="" prompt="&gt; " ShowLabels="true"/>
<Styles>
<Font name="Ordered List 1" background="[255,255,255]" bold="false" executable="false" family="Times New Roman" foreground="[0,0,0]" italic="false" opaque="false" readonly="false" size="12" subscript="false" superscript="false" underline="false" placeholder="false"/>
<Font name="Annotation Text" background="[255,255,255]" bold="false" executable="false" family="Times New Roman" foreground="[0,0,0]" italic="false" opaque="false" readonly="false" size="12" subscript="false" superscript="false" underline="false" placeholder="false"/>
<Font name="Ordered List 2" background="[255,255,255]" bold="false" executable="false" family="Times New Roman" foreground="[0,0,0]" italic="false" opaque="false" readonly="false" size="12" subscript="false" superscript="false" underline="false" placeholder="false"/>
<Font name="Ordered List 3" background="[255,255,255]" bold="false" executable="false" family="Times New Roman" foreground="[0,0,0]" italic="false" opaque="false" readonly="false" size="12" subscript="false" superscript="false" underline="false" placeholder="false"/>
<Font name="Ordered List 4" background="[255,255,255]" bold="false" executable="false" family="Times New Roman" foreground="[0,0,0]" italic="false" opaque="false" readonly="false" size="12" subscript="false" superscript="false" underline="false" placeholder="false"/>
<Font name="Ordered List 5" background="[255,255,255]" bold="false" executable="false" family="Times New Roman" foreground="[0,0,0]" italic="false" opaque="false" readonly="false" size="12" subscript="false" superscript="false" underline="false" placeholder="false"/>
<Font name="Author" background="[255,255,255]" bold="false" executable="false" family="Times New Roman" foreground="[0,0,0]" italic="false" opaque="false" readonly="false" size="12" subscript="false" superscript="false" underline="false" placeholder="false"/>
<Font name="Annotation Title" background="[255,255,255]" bold="true" executable="false" family="Times New Roman" foreground="[0,0,0]" italic="false" opaque="false" readonly="false" size="18" subscript="false" superscript="false" underline="false" placeholder="false"/>
<Font name="Warning" background="[255,255,255]" bold="false" executable="false" family="Courier New" foreground="[0,0,255]" italic="false" opaque="false" readonly="true" size="12" subscript="false" superscript="false" underline="false" placeholder="false"/>
<Font name="Caption Reference" background="[255,255,255]" bold="true" executable="false" family="Times New Roman" foreground="[0,0,0]" italic="false" opaque="false" readonly="false" size="12" subscript="false" superscript="false" underline="false" placeholder="false"/>
<Font name="Maple Input Placeholder" background="[255,255,255]" bold="true" executable="true" family="Courier New" foreground="[200,0,200]" italic="false" opaque="false" readonly="false" size="12" subscript="false" superscript="false" underline="false" placeholder="true"/>
<Font name="Maple Plot" background="[255,255,255]" bold="false" executable="false" family="Times New Roman" foreground="[0,0,0]" italic="false" opaque="false" readonly="false" size="12" subscript="false" superscript="false" underline="false" placeholder="false"/>
<Font name="Code" background="[255,255,255]" bold="false" executable="false" family="Courier New" foreground="[255,0,0]" italic="false" opaque="false" readonly="false" size="12" subscript="false" superscript="false" underline="false" placeholder="false"/>
<Font name="Line Printed Output" background="[255,255,255]" bold="false" executable="false" family="Courier New" foreground="[0,0,255]" italic="false" opaque="false" readonly="true" size="12" subscript="false" superscript="false" underline="false" placeholder="false"/>
<Font name="Text Output" background="[255,255,255]" bold="false" executable="false" family="Courier New" foreground="[0,0,255]" italic="false" opaque="false" readonly="true" size="12" subscript="false" superscript="false" underline="false" placeholder="false"/>
<Font name="Diagnostic" background="[255,255,255]" bold="false" executable="false" family="Courier New" foreground="[40,120,40]" italic="false" opaque="false" readonly="true" size="12" subscript="false" superscript="false" underline="false" placeholder="false"/>
<Font name="2D Inert Output" background="[255,255,255]" bold="false" executable="true" family="Times New Roman" foreground="[144,144,144]" italic="false" opaque="false" readonly="false" size="12" subscript="false" superscript="false" underline="false" placeholder="false"/>
<Font name="Normal" background="[255,255,255]" bold="false" executable="false" family="Times New Roman" foreground="[0,0,0]" italic="false" opaque="false" readonly="false" size="12" subscript="false" superscript="false" underline="false" placeholder="false"/>
<Font name="Hyperlink" background="[255,255,255]" bold="false" executable="false" family="Times New Roma" foreground="[0,128,128]" italic="false" opaque="false" readonly="false" size="12" subscript="false" superscript="false" underline="true" placeholder="false"/>
<Font name="Maple Output" background="[255,255,255]" bold="false" executable="false" family="Times New Roman" foreground="[0,0,0]" italic="false" opaque="false" readonly="false" size="12" subscript="false" superscript="false" underline="false" placeholder="false"/>
<Font name="Dash Item" background="[255,255,255]" bold="false" executable="false" family="Times New Roman" foreground="[0,0,0]" italic="false" opaque="false" readonly="false" size="12" subscript="false" superscript="false" underline="false" placeholder="false"/>
<Font name="2D Math" background="[255,255,255]" bold="false" executable="false" family="Times New Roman" foreground="[0,0,0]" italic="false" opaque="false" readonly="false" size="12" subscript="false" superscript="false" underline="false" placeholder="false"/>
<Font name="Maple Input" background="[0,0,0]" bold="true" executable="true" family="Monospaced" foreground="[255,0,0]" italic="false" opaque="false" readonly="false" size="12" subscript="false" superscript="false" underline="false" placeholder="false"/>
<Font name="2D Output" background="[255,255,255]" bold="false" executable="false" family="Times New Roman" foreground="[0,0,255]" italic="false" opaque="false" readonly="true" size="12" subscript="false" superscript="false" underline="false" placeholder="false"/>
<Font name="2D Input" background="[255,255,255]" bold="false" executable="true" family="Times New Roman" foreground="[0,0,0]" italic="false" opaque="false" readonly="false" size="12" subscript="false" superscript="false" underline="false" placeholder="false"/>
<Font name="HyperlinkError" background="[255,255,255]" bold="false" executable="false" family="Courier New" foreground="[255,0,255]" italic="false" opaque="false" readonly="true" size="12" subscript="false" superscript="false" underline="true" placeholder="false"/>
<Font name="Header and Footer" background="[255,255,255]" bold="false" executable="false" family="Times New Roman" foreground="[0,0,0]" italic="false" opaque="false" readonly="false" size="10" subscript="false" superscript="false" underline="false" placeholder="false"/>
<Font name="Error" background="[255,255,255]" bold="false" executable="false" family="Courier New" foreground="[255,0,255]" italic="false" opaque="false" readonly="true" size="12" subscript="false" superscript="false" underline="false" placeholder="false"/>
<Font name="Title" background="[255,255,255]" bold="true" executable="false" family="Times New Roman" foreground="[0,0,0]" italic="false" opaque="false" readonly="false" size="18" subscript="false" superscript="false" underline="false" placeholder="false"/>
<Font name="Heading 1" background="[255,255,255]" bold="true" executable="false" family="Times New Roma" foreground="[0,0,0]" italic="false" opaque="false" readonly="false" size="18" subscript="false" superscript="false" underline="false" placeholder="false"/>
<Font name="Text" background="[255,255,255]" bold="false" executable="false" family="Times New Roman" foreground="[0,0,0]" italic="false" opaque="false" readonly="false" size="12" subscript="false" superscript="false" underline="false" placeholder="false"/>
<Font name="Bullet Item" background="[255,255,255]" bold="false" executable="false" family="Times New Roman" foreground="[0,0,0]" italic="false" opaque="false" readonly="false" size="12" subscript="false" superscript="false" underline="false" placeholder="false"/>
<Font name="Heading 4" background="[255,255,255]" bold="false" executable="false" family="Times New Roma" foreground="[0,0,0]" italic="true" opaque="false" readonly="false" size="12" subscript="false" superscript="false" underline="false" placeholder="false"/>
<Font name="Equation Label" background="[255,255,255]" bold="true" executable="false" family="Times New Roman" foreground="[0,0,0]" italic="false" opaque="false" readonly="false" size="12" subscript="false" superscript="false" underline="false" placeholder="false"/>
<Font name="Heading 3" background="[255,255,255]" bold="true" executable="false" family="Times New Roma" foreground="[0,0,0]" italic="true" opaque="false" readonly="false" size="14" subscript="false" superscript="false" underline="false" placeholder="false"/>
<Font name="Heading 2" background="[255,255,255]" bold="true" executable="false" family="Times New Roma" foreground="[0,0,0]" italic="false" opaque="false" readonly="false" size="16" subscript="false" superscript="false" underline="false" placeholder="false"/>
<Font name="HyperlinkWarning" background="[255,255,255]" bold="false" executable="false" family="Courier New" foreground="[0,0,255]" italic="false" opaque="false" readonly="true" size="12" subscript="false" superscript="false" underline="true" placeholder="false"/>
<Font name="Dictionary Hyperlink" background="[255,255,255]" bold="false" executable="false" family="Times New Roma" foreground="[147,0,15]" italic="false" opaque="false" readonly="false" size="12" subscript="false" superscript="false" underline="true" placeholder="false"/>
<Font name="Atomic Variable" background="[255,255,255]" bold="false" executable="false" family="Times New Roman" foreground="[175,0,175]" italic="true" opaque="false" readonly="false" size="12" subscript="false" superscript="false" underline="false" placeholder="false"/>
<Font name="Caption Text" background="[255,255,255]" bold="true" executable="false" family="Times New Roman" foreground="[0,0,0]" italic="false" opaque="false" readonly="false" size="12" subscript="false" superscript="false" underline="false" placeholder="false"/>
<Font name="List Item" background="[255,255,255]" bold="false" executable="false" family="Times New Roman" foreground="[0,0,0]" italic="false" opaque="false" readonly="false" size="12" subscript="false" superscript="false" underline="false" placeholder="false"/>
<Layout name="Ordered List 1" alignment="left" bullet="numeric" firstindent="0" leftmargin="0" rightmargin="0" linespacing="0.0" spaceabove="3" spacebelow="3" linebreak="space" pagebreak-before="false" initial="-1" bulletsuffix=""/>
<Layout name="Ordered List 2" alignment="left" bullet="alphabetic" firstindent="0" leftmargin="36" rightmargin="0" linespacing="0.0" spaceabove="3" spacebelow="3" linebreak="space" pagebreak-before="false" initial="-1" bulletsuffix=""/>
<Layout name="Ordered List 3" alignment="left" bullet="roman" firstindent="0" leftmargin="72" rightmargin="0" linespacing="0.0" spaceabove="3" spacebelow="3" linebreak="space" pagebreak-before="false" initial="-1" bulletsuffix=""/>
<Layout name="Ordered List 4" alignment="left" bullet="ALPHABETIC" firstindent="0" leftmargin="108" rightmargin="0" linespacing="0.0" spaceabove="3" spacebelow="3" linebreak="space" pagebreak-before="false" initial="-1" bulletsuffix=""/>
<Layout name="Ordered List 5" alignment="left" bullet="ROMAN" firstindent="0" leftmargin="144" rightmargin="0" linespacing="0.0" spaceabove="3" spacebelow="3" linebreak="space" pagebreak-before="false" initial="-1" bulletsuffix=""/>
<Layout name="Author" alignment="centred" bullet="none" firstindent="0" leftmargin="0" rightmargin="0" linespacing="0.0" spaceabove="8" spacebelow="8" linebreak="space" pagebreak-before="false" initial="0" bulletsuffix=""/>
<Layout name="Warning" alignment="left" bullet="none" firstindent="0" leftmargin="0" rightmargin="0" linespacing="0.0" spaceabove="0" spacebelow="0" linebreak="space" pagebreak-before="false" initial="0" bulletsuffix=""/>
<Layout name="Annotation Title" alignment="centred" bullet="none" firstindent="0" leftmargin="0" rightmargin="0" linespacing="0.0" spaceabove="12" spacebelow="12" linebreak="space" pagebreak-before="false" initial="0" bulletsuffix=""/>
<Layout name="Maple Plot" alignment="centred" bullet="none" firstindent="0" leftmargin="0" rightmargin="0" linespacing="0.0" spaceabove="0" spacebelow="0" linebreak="space" pagebreak-before="false" initial="0" bulletsuffix=""/>
<Layout name="Line Printed Output" alignment="left" bullet="none" firstindent="0" leftmargin="0" rightmargin="0" linespacing="0.0" spaceabove="0" spacebelow="0" linebreak="any" pagebreak-before="false" initial="0" bulletsuffix=""/>
<Layout name="Text Output" alignment="left" bullet="none" firstindent="0" leftmargin="0" rightmargin="0" linespacing="0.0" spaceabove="0" spacebelow="0" linebreak="newline" pagebreak-before="false" initial="0" bulletsuffix=""/>
<Layout name="Diagnostic" alignment="left" bullet="none" firstindent="0" leftmargin="0" rightmargin="0" linespacing="0.0" spaceabove="0" spacebelow="0" linebreak="any" pagebreak-before="false" initial="0" bulletsuffix=""/>
<Layout name="Normal" alignment="left" bullet="none" firstindent="0" leftmargin="0" rightmargin="0" linespacing="0.0" spaceabove="0" spacebelow="0" linebreak="space" pagebreak-before="false" initial="0" bulletsuffix=""/>
<Layout name="Maple Output" alignment="centred" bullet="none" firstindent="0" leftmargin="0" rightmargin="0" linespacing="0.3" spaceabove="0" spacebelow="0" linebreak="space" pagebreak-before="false" initial="0" bulletsuffix=""/>
<Layout name="Dash Item" alignment="left" bullet="dash" firstindent="0" leftmargin="0" rightmargin="0" linespacing="0.0" spaceabove="3" spacebelow="3" linebreak="space" pagebreak-before="false" initial="0" bulletsuffix=""/>
<Layout name="HyperlinkError" alignment="left" bullet="none" firstindent="0" leftmargin="0" rightmargin="0" linespacing="0.0" spaceabove="0" spacebelow="0" linebreak="space" pagebreak-before="false" initial="0" bulletsuffix=""/>
<Layout name="Error" alignment="left" bullet="none" firstindent="0" leftmargin="0" rightmargin="0" linespacing="0.0" spaceabove="0" spacebelow="0" linebreak="space" pagebreak-before="false" initial="0" bulletsuffix=""/>
<Layout name="Title" alignment="centred" bullet="none" firstindent="0" leftmargin="0" rightmargin="0" linespacing="0.0" spaceabove="12" spacebelow="12" linebreak="space" pagebreak-before="false" initial="0" bulletsuffix=""/>
<Layout name="Heading 1" alignment="left" bullet="none" firstindent="0" leftmargin="0" rightmargin="0" linespacing="0.0" spaceabove="8" spacebelow="4" linebreak="space" pagebreak-before="false" initial="0" bulletsuffix=""/>
<Layout name="Bullet Item" alignment="left" bullet="dot" firstindent="0" leftmargin="0" rightmargin="0" linespacing="0.0" spaceabove="3" spacebelow="3" linebreak="space" pagebreak-before="false" initial="0" bulletsuffix=""/>
<Layout name="Heading 4" alignment="left" bullet="none" firstindent="0" leftmargin="0" rightmargin="0" linespacing="0.0" spaceabove="0" spacebelow="0" linebreak="space" pagebreak-before="false" initial="0" bulletsuffix=""/>
<Layout name="Heading 3" alignment="left" bullet="none" firstindent="0" leftmargin="0" rightmargin="0" linespacing="0.0" spaceabove="0" spacebelow="0" linebreak="space" pagebreak-before="false" initial="0" bulletsuffix=""/>
<Layout name="Heading 2" alignment="left" bullet="none" firstindent="0" leftmargin="0" rightmargin="0" linespacing="0.0" spaceabove="8" spacebelow="2" linebreak="space" pagebreak-before="false" initial="0" bulletsuffix=""/>
<Layout name="HyperlinkWarning" alignment="left" bullet="none" firstindent="0" leftmargin="0" rightmargin="0" linespacing="0.0" spaceabove="0" spacebelow="0" linebreak="space" pagebreak-before="false" initial="0" bulletsuffix=""/>
<Layout name="List Item" alignment="left" bullet="indent" firstindent="0" leftmargin="0" rightmargin="0" linespacing="0.0" spaceabove="3" spacebelow="3" linebreak="space" pagebreak-before="false" initial="0" bulletsuffix=""/>
<Pencil-style name="Pencil 5" pen-color="[255,0,0]" pen-height="5.0" pen-width="5.0" pen-opacity="1.0"/>
<Pencil-style name="Pencil 4" pen-color="[0,0,255]" pen-height="3.0" pen-width="3.0" pen-opacity="1.0"/>
<Pencil-style name="Pencil 3" pen-color="[0,0,0]" pen-height="3.0" pen-width="3.0" pen-opacity="1.0"/>
<Pencil-style name="Pencil 2" pen-color="[0,0,255]" pen-height="1.0" pen-width="1.0" pen-opacity="1.0"/>
<Pencil-style name="Pencil 1" pen-color="[0,0,0]" pen-height="1.0" pen-width="1.0" pen-opacity="1.0"/>
<Highlighter-style name="Highlighter 2" pen-color="[255,204,0]" pen-height="14.0" pen-width="14.0" pen-opacity="0.8"/>
<Highlighter-style name="Highlighter 1" pen-color="[255,153,255]" pen-height="12.0" pen-width="8.0" pen-opacity="0.8"/>
<Highlighter-style name="Highlighter 4" pen-color="[0,255,255]" pen-height="32.0" pen-width="32.0" pen-opacity="0.8"/>
<Highlighter-style name="Highlighter 3" pen-color="[51,255,0]" pen-height="24.0" pen-width="24.0" pen-opacity="0.8"/>
<Highlighter-style name="Highlighter 5" pen-color="[255,255,0]" pen-height="48.0" pen-width="48.0" pen-opacity="0.8"/>
</Styles>
<Task-table>
    <Task-category name="&lt;default&gt;"/>
</Task-table>
<Task/>
<Group labelreference="L2">
<Input>
<Text-field prompt="&gt; " style="Maple Input" layout="Normal">with(linalg):with(LinearAlgebra):with(combinat):</Text-field>
<Text-field prompt="&gt; " style="Maple Input" layout="Normal">kernelopts(assertlevel=1):       ### Enable checking ASSERTions</Text-field>
<Text-field prompt="&gt; " style="Maple Input" layout="Normal"></Text-field>
<Text-field prompt="&gt; " style="Maple Input" layout="Normal">insert:=proc(K,L) local out;</Text-field>
<Text-field prompt="&gt; " style="Maple Input" layout="Normal">    out:=[seq(L[K[i]],i=1..nops(K))];</Text-field>
<Text-field prompt="&gt; " style="Maple Input" layout="Normal">end:</Text-field>
<Text-field prompt="&gt; " style="Maple Input" layout="Normal">#The output is the Complement  List, within the list [1,..,d]</Text-field>
<Text-field prompt="&gt; " style="Maple Input" layout="Normal">ComplementList:=proc(K,d);</Text-field>
<Text-field prompt="&gt; " style="Maple Input" layout="Normal">    RETURN([seq (`if` (member(i,K)=false, i, op({})),i=1..d)]);</Text-field>
<Text-field prompt="&gt; " style="Maple Input" layout="Normal">end:</Text-field>
<Text-field prompt="&gt; " style="Maple Input" layout="Normal">#The output is the Complement  List, within the list [a[1],..,a[d]]</Text-field>
<Text-field prompt="&gt; " style="Maple Input" layout="Normal">GeneralComplementList:=proc(K,L)local d;d:=nops(L);</Text-field>
<Text-field prompt="&gt; " style="Maple Input" layout="Normal">    RETURN([seq (`if` (member(L[i],K)=false, L[i], op({})),i=1..d)]);</Text-field>
<Text-field prompt="&gt; " style="Maple Input" layout="Normal">end:</Text-field>
<Text-field prompt="&gt; " style="Maple Input" layout="Normal">special_lincomb_v:=proc(a,v,n) local out;</Text-field>
<Text-field prompt="&gt; " style="Maple Input" layout="Normal">    ASSERT(nops(a)=nops(v),&quot; the number of coefficients and vectors do not match&quot;);</Text-field>
<Text-field prompt="&gt; " style="Maple Input" layout="Normal">    if v=[]   then out:=[seq(0,i=1..n)];else</Text-field>
<Text-field prompt="&gt; " style="Maple Input" layout="Normal">        out:=[seq(add(a[i]*v[i][j],i=1..nops(v)),j=1..nops(v[1]))];</Text-field>
<Text-field prompt="&gt; " style="Maple Input" layout="Normal">    fi;</Text-field>
<Text-field prompt="&gt; " style="Maple Input" layout="Normal">    out;</Text-field>
<Text-field prompt="&gt; " style="Maple Input" layout="Normal">end:</Text-field>
<Text-field prompt="&gt; " style="Maple Input" layout="Normal">primitive_vector:=proc(A) local d,n,g;</Text-field>
<Text-field prompt="&gt; " style="Maple Input" layout="Normal">    d:=nops(A);</Text-field>
<Text-field prompt="&gt; " style="Maple Input" layout="Normal">    n:=ilcm(seq(denom(A[i]),i=1..d));</Text-field>
<Text-field prompt="&gt; " style="Maple Input" layout="Normal">    g:=igcd(seq(n*A[i],i=1..d));</Text-field>
<Text-field prompt="&gt; " style="Maple Input" layout="Normal">    if g&lt;&gt;0 then</Text-field>
<Text-field prompt="&gt; " style="Maple Input" layout="Normal">        [seq(n*A[i]/g,i=1..d)];</Text-field>
<Text-field prompt="&gt; " style="Maple Input" layout="Normal">    else</Text-field>
<Text-field prompt="&gt; " style="Maple Input" layout="Normal">        [seq(n*A[i],i=1..d)];</Text-field>
<Text-field prompt="&gt; " style="Maple Input" layout="Normal">    fi;</Text-field>
<Text-field prompt="&gt; " style="Maple Input" layout="Normal">end:</Text-field>
<Text-field prompt="&gt; " style="Maple Input" layout="Normal">ortho_basis:=proc(d) local i,v;</Text-field>
<Text-field prompt="&gt; " style="Maple Input" layout="Normal">    for i from 1 to d do</Text-field>
<Text-field prompt="&gt; " style="Maple Input" layout="Normal">        v[i]:=[seq(0,j=1..i-1),1,seq(0,j=i+1..d)]</Text-field>
<Text-field prompt="&gt; " style="Maple Input" layout="Normal">    od;</Text-field>
<Text-field prompt="&gt; " style="Maple Input" layout="Normal">    [seq(v[j],j=1..d)];</Text-field>
<Text-field prompt="&gt; " style="Maple Input" layout="Normal">end:</Text-field>
<Text-field prompt="&gt; " style="Maple Input" layout="Normal">fracpart:=proc(x);</Text-field>
<Text-field prompt="&gt; " style="Maple Input" layout="Normal">    x-floor(x);</Text-field>
<Text-field prompt="&gt; " style="Maple Input" layout="Normal">end:</Text-field>
<Text-field prompt="&gt; " style="Maple Input" layout="Normal"></Text-field>
<Text-field prompt="&gt; " style="Maple Input" layout="Normal">short_vector:=proc(A) local n,base,i,sho;</Text-field>
<Text-field prompt="&gt; " style="Maple Input" layout="Normal">    n:=nops(A);</Text-field>
<Text-field prompt="&gt; " style="Maple Input" layout="Normal">    base:=IntegerRelations[LLL](A);</Text-field>
<Text-field prompt="&gt; " style="Maple Input" layout="Normal">    sho:=base[1];</Text-field>
<Text-field prompt="&gt; " style="Maple Input" layout="Normal">    i:=1;</Text-field>
<Text-field prompt="&gt; " style="Maple Input" layout="Normal">    while i&lt;=n-1 do</Text-field>
<Text-field prompt="&gt; " style="Maple Input" layout="Normal">        if max(seq(abs(sho[j]),j=1..n))&lt;=max(seq(abs(base[i+1][j]),j=1..n))</Text-field>
<Text-field prompt="&gt; " style="Maple Input" layout="Normal">        then sho:=sho; else sho:=base[i+1];</Text-field>
<Text-field prompt="&gt; " style="Maple Input" layout="Normal">        fi;</Text-field>
<Text-field prompt="&gt; " style="Maple Input" layout="Normal">        i:=i+1;</Text-field>
<Text-field prompt="&gt; " style="Maple Input" layout="Normal">    od;</Text-field>
<Text-field prompt="&gt; " style="Maple Input" layout="Normal">    sho;</Text-field>
<Text-field prompt="&gt; " style="Maple Input" layout="Normal">end:</Text-field>
<Text-field prompt="&gt; " style="Maple Input" layout="Normal"></Text-field>
<Text-field prompt="&gt; " style="Maple Input" layout="Normal"></Text-field>
<Text-field prompt="&gt; " style="Maple Input" layout="Normal">sign_entries_vector:=proc(V) local d,i,Lplus,Lminus,Lzero;</Text-field>
<Text-field prompt="&gt; " style="Maple Input" layout="Normal">    d:=nops(V); Lplus:=[]; Lminus:=[];Lzero:=[];</Text-field>
<Text-field prompt="&gt; " style="Maple Input" layout="Normal"></Text-field>
<Text-field prompt="&gt; " style="Maple Input" layout="Normal">    for i from 1 to d do</Text-field>
<Text-field prompt="&gt; " style="Maple Input" layout="Normal">        if type(V[i],positive)      then Lplus:=[op(Lplus),i];</Text-field>
<Text-field prompt="&gt; " style="Maple Input" layout="Normal">        elif type(V[i],negative) then Lminus:=[op(Lminus),i];</Text-field>
<Text-field prompt="&gt; " style="Maple Input" layout="Normal">        else Lzero:=[op(Lzero),i];</Text-field>
<Text-field prompt="&gt; " style="Maple Input" layout="Normal">        fi;</Text-field>
<Text-field prompt="&gt; " style="Maple Input" layout="Normal">    od;</Text-field>
<Text-field prompt="&gt; " style="Maple Input" layout="Normal">    [Lplus,Lminus,Lzero];</Text-field>
<Text-field prompt="&gt; " style="Maple Input" layout="Normal">end:</Text-field>
<Text-field prompt="&gt; " style="Maple Input" layout="Normal"></Text-field>
<Text-field prompt="&gt; " style="Maple Input" layout="Normal">good_vector:=proc(G) local n,A,Ainverse,B,sho,V,L;</Text-field>
<Text-field prompt="&gt; " style="Maple Input" layout="Normal">    n:=nops(G);</Text-field>
<Text-field prompt="&gt; " style="Maple Input" layout="Normal">    Ainverse:=inverse(matrix(G));</Text-field>
<Text-field prompt="&gt; " style="Maple Input" layout="Normal">    B:=convert(Ainverse, listlist);</Text-field>
<Text-field prompt="&gt; " style="Maple Input" layout="Normal">    sho:=short_vector(B);</Text-field>
<Text-field prompt="&gt; " style="Maple Input" layout="Normal">    V :=[seq(add(G[j][i]*sho[j],j=1..n),i=1..n)];</Text-field>
<Text-field prompt="&gt; " style="Maple Input" layout="Normal">    L:= sign_entries_vector(sho);</Text-field>
<Text-field prompt="&gt; " style="Maple Input" layout="Normal">    [V,L];</Text-field>
<Text-field prompt="&gt; " style="Maple Input" layout="Normal">end:</Text-field>
<Text-field prompt="&gt; " style="Maple Input" layout="Normal"></Text-field>
<Text-field prompt="&gt; " style="Maple Input" layout="Normal">signed_decomp:=proc(eps,G,v,L) local Nonuni,Uni,Lplus,Lminus,Lzero,kplus,kminus,kzero,i,j, C,M, detC, Csigned ;</Text-field>
<Text-field prompt="&gt; " style="Maple Input" layout="Normal">    Nonuni:=[]; Uni:=[];</Text-field>
<Text-field prompt="&gt; " style="Maple Input" layout="Normal">    Lplus:=L[1]; Lminus:=L[2]; Lzero:=L[3];</Text-field>
<Text-field prompt="&gt; " style="Maple Input" layout="Normal">    kplus:=nops(Lplus); kminus:=nops(Lminus); kzero:=nops(Lzero);</Text-field>
<Text-field prompt="&gt; " style="Maple Input" layout="Normal">    if kplus&gt;0 then</Text-field>
<Text-field prompt="&gt; " style="Maple Input" layout="Normal">        for i from 1 to kplus do</Text-field>
<Text-field prompt="&gt; " style="Maple Input" layout="Normal">            C:=[seq(G[Lplus[j]],j=1..i-1),seq(-G[Lplus[j]],j=i+1..kplus),v,seq(G[Lminus[j]],j=1..kminus),seq(G[Lzero[j]],j=1..kzero)];</Text-field>
<Text-field prompt="&gt; " style="Maple Input" layout="Normal"></Text-field>
<Text-field prompt="&gt; " style="Maple Input" layout="Normal">            detC := det(matrix(C));</Text-field>
<Text-field prompt="&gt; " style="Maple Input" layout="Normal">            Csigned:=[eps*(-1)^(i+kplus),detC,C];</Text-field>
<Text-field prompt="&gt; " style="Maple Input" layout="Normal"></Text-field>
<Text-field prompt="&gt; " style="Maple Input" layout="Normal">            if abs(detC)&gt;1 then</Text-field>
<Text-field prompt="&gt; " style="Maple Input" layout="Normal">                Nonuni:=[op(Nonuni),Csigned] else Uni:=[op(Uni),Csigned];</Text-field>
<Text-field prompt="&gt; " style="Maple Input" layout="Normal">            fi;</Text-field>
<Text-field prompt="&gt; " style="Maple Input" layout="Normal">        od;</Text-field>
<Text-field prompt="&gt; " style="Maple Input" layout="Normal">    fi;</Text-field>
<Text-field prompt="&gt; " style="Maple Input" layout="Normal"></Text-field>
<Text-field prompt="&gt; " style="Maple Input" layout="Normal">    if kminus&gt;0 then</Text-field>
<Text-field prompt="&gt; " style="Maple Input" layout="Normal">        for i from 1 to kminus do</Text-field>
<Text-field prompt="&gt; " style="Maple Input" layout="Normal">            C:=[seq(G[Lplus[j]],j=1..kplus),-v,seq(-G[Lminus[j]],j=1..i-1),seq(G[Lminus[j]],j=i+1..kminus),seq(G[Lzero[j]],j=1..kzero)];</Text-field>
<Text-field prompt="&gt; " style="Maple Input" layout="Normal"></Text-field>
<Text-field prompt="&gt; " style="Maple Input" layout="Normal">            detC := det(matrix(C));</Text-field>
<Text-field prompt="&gt; " style="Maple Input" layout="Normal">            Csigned:=[eps*(-1)^(i+1),detC,C];</Text-field>
<Text-field prompt="&gt; " style="Maple Input" layout="Normal"></Text-field>
<Text-field prompt="&gt; " style="Maple Input" layout="Normal">            if abs(detC)&gt;1 then</Text-field>
<Text-field prompt="&gt; " style="Maple Input" layout="Normal">                Nonuni:=[op(Nonuni),Csigned] else Uni:=[op(Uni), Csigned];</Text-field>
<Text-field prompt="&gt; " style="Maple Input" layout="Normal">            fi;</Text-field>
<Text-field prompt="&gt; " style="Maple Input" layout="Normal">        od;</Text-field>
<Text-field prompt="&gt; " style="Maple Input" layout="Normal">    end if;</Text-field>
<Text-field prompt="&gt; " style="Maple Input" layout="Normal">    [Nonuni,Uni];</Text-field>
<Text-field prompt="&gt; " style="Maple Input" layout="Normal">end:</Text-field>
<Text-field prompt="&gt; " style="Maple Input" layout="Normal"></Text-field>
<Text-field prompt="&gt; " style="Maple Input" layout="Normal">good_cone_dec:=proc(eps,G) local n,A,R,Output, det_A;</Text-field>
<Text-field prompt="&gt; " style="Maple Input" layout="Normal">    n:=nops(G);  A:=matrix([seq(G[i],i=1..n)]);</Text-field>
<Text-field prompt="&gt; " style="Maple Input" layout="Normal">    det_A:=det(A);</Text-field>
<Text-field prompt="&gt; " style="Maple Input" layout="Normal">    if abs(det_A)=1 then</Text-field>
<Text-field prompt="&gt; " style="Maple Input" layout="Normal">        Output:=[[],[[eps,det_A,G]]];</Text-field>
<Text-field prompt="&gt; " style="Maple Input" layout="Normal">    else R:=good_vector(G);</Text-field>
<Text-field prompt="&gt; " style="Maple Input" layout="Normal">        Output:=signed_decomp(eps,G,R[1],R[2]);</Text-field>
<Text-field prompt="&gt; " style="Maple Input" layout="Normal">    fi;</Text-field>
<Text-field prompt="&gt; " style="Maple Input" layout="Normal">end:</Text-field>
<Text-field prompt="&gt; " style="Maple Input" layout="Normal"></Text-field>
<Text-field prompt="&gt; " style="Maple Input" layout="Normal">more_decomposition_in_cones:=proc(cones) local i,Newuni,Newnonuni,newcones:</Text-field>
<Text-field prompt="&gt; " style="Maple Input" layout="Normal">    Newnonuni:=[];</Text-field>
<Text-field prompt="&gt; " style="Maple Input" layout="Normal">    Newuni:=cones[2];</Text-field>
<Text-field prompt="&gt; " style="Maple Input" layout="Normal">    for i from 1 to nops(cones[1]) do</Text-field>
<Text-field prompt="&gt; " style="Maple Input" layout="Normal">        newcones:=good_cone_dec(cones[1][i][1],cones[1][i][3]);</Text-field>
<Text-field prompt="&gt; " style="Maple Input" layout="Normal">        Newnonuni:=[op(Newnonuni),op(newcones[1])];</Text-field>
<Text-field prompt="&gt; " style="Maple Input" layout="Normal">        Newuni:=[op(Newuni),op(newcones[2])];</Text-field>
<Text-field prompt="&gt; " style="Maple Input" layout="Normal">    od;</Text-field>
<Text-field prompt="&gt; " style="Maple Input" layout="Normal">    [Newnonuni,Newuni];</Text-field>
<Text-field prompt="&gt; " style="Maple Input" layout="Normal">end:</Text-field>
<Text-field prompt="&gt; " style="Maple Input" layout="Normal"></Text-field>
<Text-field prompt="&gt; " style="Maple Input" layout="Normal">cone_dec:=proc(G) local seed, i,ok;</Text-field>
<Text-field prompt="&gt; " style="Maple Input" layout="Normal">    if G=[] then</Text-field>
<Text-field prompt="&gt; " style="Maple Input" layout="Normal">        RETURN([[1,1,[]]]);</Text-field>
<Text-field prompt="&gt; " style="Maple Input" layout="Normal">    fi:</Text-field>
<Text-field prompt="&gt; " style="Maple Input" layout="Normal">    seed:=good_cone_dec(1,G);</Text-field>
<Text-field prompt="&gt; " style="Maple Input" layout="Normal">    ok:=0;</Text-field>
<Text-field prompt="&gt; " style="Maple Input" layout="Normal">    i:=1;</Text-field>
<Text-field prompt="&gt; " style="Maple Input" layout="Normal">    while ok=0  do</Text-field>
<Text-field prompt="&gt; " style="Maple Input" layout="Normal">        seed:=more_decomposition_in_cones(seed);</Text-field>
<Text-field prompt="&gt; " style="Maple Input" layout="Normal">        if seed[1]=[] then</Text-field>
<Text-field prompt="&gt; " style="Maple Input" layout="Normal">            ok:=1;else ok:=0;i:=i+1;</Text-field>
<Text-field prompt="&gt; " style="Maple Input" layout="Normal">        fi;</Text-field>
<Text-field prompt="&gt; " style="Maple Input" layout="Normal">    od;</Text-field>
<Text-field prompt="&gt; " style="Maple Input" layout="Normal">    RETURN(seed[2]);</Text-field>
<Text-field prompt="&gt; " style="Maple Input" layout="Normal">end:</Text-field>
<Text-field prompt="&gt; " style="Maple Input" layout="Normal">projectedvector:=proc(W,Cspace,b) local M,S,j,v,V,m;</Text-field>
<Text-field prompt="&gt; " style="Maple Input" layout="Normal">    M:=transpose(matrix([seq(W[i],i=1..nops(W))]));</Text-field>
<Text-field prompt="&gt; " style="Maple Input" layout="Normal">    S:=linsolve(M,b);</Text-field>
<Text-field prompt="&gt; " style="Maple Input" layout="Normal">    m:=det(M);</Text-field>
<Text-field prompt="&gt; " style="Maple Input" layout="Normal">    for j from 1 to nops(W) do</Text-field>
<Text-field prompt="&gt; " style="Maple Input" layout="Normal">        v[j]:=add(S[Cspace[i]]*W[Cspace[i]][j],i=1..nops(Cspace));</Text-field>
<Text-field prompt="&gt; " style="Maple Input" layout="Normal">    od:</Text-field>
<Text-field prompt="&gt; " style="Maple Input" layout="Normal">    V:=[seq(v[j],j=1..nops(W))];</Text-field>
<Text-field prompt="&gt; " style="Maple Input" layout="Normal">end:</Text-field>
<Text-field prompt="&gt; " style="Maple Input" layout="Normal">projectedvector_with_inverse:=proc(M_inverse, W,Cspace,b) local S,j,v,V;</Text-field>
<Text-field prompt="&gt; " style="Maple Input" layout="Normal">    S:=multiply(M_inverse,b);</Text-field>
<Text-field prompt="&gt; " style="Maple Input" layout="Normal">    for j from 1 to nops(W) do</Text-field>
<Text-field prompt="&gt; " style="Maple Input" layout="Normal">        v[j]:=add(S[Cspace[i]]*W[Cspace[i]][j],i=1..nops(Cspace));</Text-field>
<Text-field prompt="&gt; " style="Maple Input" layout="Normal">    od:</Text-field>
<Text-field prompt="&gt; " style="Maple Input" layout="Normal">    V:=[seq(v[j],j=1..nops(W))];</Text-field>
<Text-field prompt="&gt; " style="Maple Input" layout="Normal">end:</Text-field>
<Text-field prompt="&gt; " style="Maple Input" layout="Normal">projectedlattice:=proc(W,Cspace) local m,B, d,k,i,r,S,IS,List,M_inverse, temp_projectedVectors;</Text-field>
<Text-field prompt="&gt; " style="Maple Input" layout="Normal">    d:=nops(W);</Text-field>
<Text-field prompt="&gt; " style="Maple Input" layout="Normal">    B:=ortho_basis(d);</Text-field>
<Text-field prompt="&gt; " style="Maple Input" layout="Normal">    k:=nops(Cspace);</Text-field>
<Text-field prompt="&gt; " style="Maple Input" layout="Normal">    m:=abs(det(transpose(matrix([seq(W[i],i=1..nops(W))]))));</Text-field>
<Text-field prompt="&gt; " style="Maple Input" layout="Normal"></Text-field>
<Text-field prompt="&gt; " style="Maple Input" layout="Normal">    M_inverse:=inverse(transpose(matrix([seq(W[i],i=1..nops(W))])));</Text-field>
<Text-field prompt="&gt; " style="Maple Input" layout="Normal">    for i from 1 to d do</Text-field>
<Text-field prompt="&gt; " style="Maple Input" layout="Normal"></Text-field>
<Text-field prompt="&gt; " style="Maple Input" layout="Normal">        temp_projectedVectors:=m*projectedvector_with_inverse(M_inverse, W,Cspace,B[i]);</Text-field>
<Text-field prompt="&gt; " style="Maple Input" layout="Normal">        r[i]:=[seq(temp_projectedVectors[j],j=1..nops(W))];</Text-field>
<Text-field prompt="&gt; " style="Maple Input" layout="Normal">    od;</Text-field>
<Text-field prompt="&gt; " style="Maple Input" layout="Normal">    S:=matrix([seq(r[i],i=1..d)]);;</Text-field>
<Text-field prompt="&gt; " style="Maple Input" layout="Normal">    IS:=ihermite(S);</Text-field>
<Text-field prompt="&gt; " style="Maple Input" layout="Normal">    List:=[seq(1/m*convert(row(IS,j),list),j=1..k)];</Text-field>
<Text-field prompt="&gt; " style="Maple Input" layout="Normal">    List;</Text-field>
<Text-field prompt="&gt; " style="Maple Input" layout="Normal">end:</Text-field>
<Text-field prompt="&gt; " style="Maple Input" layout="Normal">projectedconeinbasislattice:=proc(W,Cspace,ProjLattice) local P,M,output,i,F;</Text-field>
<Text-field prompt="&gt; " style="Maple Input" layout="Normal">    P:=ProjLattice;</Text-field>
<Text-field prompt="&gt; " style="Maple Input" layout="Normal">    M:=transpose(matrix([seq(P[i],i=1..nops(P))]));</Text-field>
<Text-field prompt="&gt; " style="Maple Input" layout="Normal">    output:=[];</Text-field>
<Text-field prompt="&gt; " style="Maple Input" layout="Normal">    for i from 1 to nops(Cspace) do</Text-field>
<Text-field prompt="&gt; " style="Maple Input" layout="Normal">        F:=convert(linsolve(M,Vector(W[Cspace[i]])),list);</Text-field>
<Text-field prompt="&gt; " style="Maple Input" layout="Normal">        output:=[op(output),primitive_vector(F)];</Text-field>
<Text-field prompt="&gt; " style="Maple Input" layout="Normal">    od;</Text-field>
<Text-field prompt="&gt; " style="Maple Input" layout="Normal">    output;</Text-field>
<Text-field prompt="&gt; " style="Maple Input" layout="Normal">end:</Text-field>
<Text-field prompt="&gt; " style="Maple Input" layout="Normal"></Text-field>
<Text-field prompt="&gt; " style="Maple Input" layout="Normal">projectedvertexinbasislattice:=proc(W,Cspace,ProjLattice,s) local m,P,M,output,i,F;</Text-field>
<Text-field prompt="&gt; " style="Maple Input" layout="Normal">    P:=ProjLattice;</Text-field>
<Text-field prompt="&gt; " style="Maple Input" layout="Normal">    if Cspace=[] then RETURN([]);fi;</Text-field>
<Text-field prompt="&gt; " style="Maple Input" layout="Normal">    M:=Transpose(Matrix([seq(P[i],i=1..nops(P))]));</Text-field>
<Text-field prompt="&gt; " style="Maple Input" layout="Normal">    F:=convert(LinearSolve(M,Vector(projectedvector(W,Cspace,s))),list);</Text-field>
<Text-field prompt="&gt; " style="Maple Input" layout="Normal">    output:=F;</Text-field>
<Text-field prompt="&gt; " style="Maple Input" layout="Normal">end:</Text-field>
<Text-field prompt="&gt; " style="Maple Input" layout="Normal">s_ISpace:=proc(s,W,ISpace) local M,s_in_cone_coord,s_ISpace;</Text-field>
<Text-field prompt="&gt; " style="Maple Input" layout="Normal">    M:=Matrix([seq(Vector([W[i]]),i=1..nops(W))]);</Text-field>
<Text-field prompt="&gt; " style="Maple Input" layout="Normal">    s_in_cone_coord:=convert(LinearSolve(M,Vector(s)),list);</Text-field>
<Text-field prompt="&gt; " style="Maple Input" layout="Normal">    s_ISpace:=[seq(s_in_cone_coord[ISpace[k]],k=1..nops(ISpace))];</Text-field>
<Text-field prompt="&gt; " style="Maple Input" layout="Normal">    special_lincomb_v(s_ISpace,[seq(W[ISpace[k]],k=1..nops(ISpace))],nops(W));</Text-field>
<Text-field prompt="&gt; " style="Maple Input" layout="Normal">end:</Text-field>
<Text-field prompt="&gt; " style="Maple Input" layout="Normal">Todd:=proc(z,t);</Text-field>
<Text-field prompt="&gt; " style="Maple Input" layout="Normal">    exp(z*t)*t/(1-exp(t));</Text-field>
<Text-field prompt="&gt; " style="Maple Input" layout="Normal">end:</Text-field>
<Text-field prompt="&gt; " style="Maple Input" layout="Normal">ourceil:=proc(t) local u:</Text-field>
<Text-field prompt="&gt; " style="Maple Input" layout="Normal">    if type(t,rational) then</Text-field>
<Text-field prompt="&gt; " style="Maple Input" layout="Normal">        ceil(t);</Text-field>
<Text-field prompt="&gt; " style="Maple Input" layout="Normal">    else ceil(t);</Text-field>
<Text-field prompt="&gt; " style="Maple Input" layout="Normal">    fi;</Text-field>
<Text-field prompt="&gt; " style="Maple Input" layout="Normal">end:</Text-field>
<Text-field prompt="&gt; " style="Maple Input" layout="Normal"></Text-field>
<Text-field prompt="&gt; " style="Maple Input" layout="Normal"></Text-field>
<Text-field prompt="&gt; " style="Maple Input" layout="Normal">fractionalpart:=proc(s) local our,T;</Text-field>
<Text-field prompt="&gt; " style="Maple Input" layout="Normal">    if  type(s,rational) then our:=s-floor(s);</Text-field>
<Text-field prompt="&gt; " style="Maple Input" layout="Normal">    else our:=frac(s);</Text-field>
<Text-field prompt="&gt; " style="Maple Input" layout="Normal">    fi;</Text-field>
<Text-field prompt="&gt; " style="Maple Input" layout="Normal">    RETURN(our);</Text-field>
<Text-field prompt="&gt; " style="Maple Input" layout="Normal">end:</Text-field>
<Text-field prompt="&gt; " style="Maple Input" layout="Normal">fmod:=proc(p,q,t) local u:</Text-field>
<Text-field prompt="&gt; " style="Maple Input" layout="Normal">    u:=modp(p,q);</Text-field>
<Text-field prompt="&gt; " style="Maple Input" layout="Normal">    q*frac(u*t/q);</Text-field>
<Text-field prompt="&gt; " style="Maple Input" layout="Normal">end:</Text-field>
<Text-field prompt="&gt; " style="Maple Input" layout="Normal">ourmod:=proc(p,q,t) local our,T;</Text-field>
<Text-field prompt="&gt; " style="Maple Input" layout="Normal">    if q=1 or modp(p,q)=0 then our:=0;</Text-field>
<Text-field prompt="&gt; " style="Maple Input" layout="Normal">    elif type(t,integer) then our:=modp(t*p,q);</Text-field>
<Text-field prompt="&gt; " style="Maple Input" layout="Normal">    else our:=q*frac(modp(p,q)*t/q);</Text-field>
<Text-field prompt="&gt; " style="Maple Input" layout="Normal">    fi;</Text-field>
<Text-field prompt="&gt; " style="Maple Input" layout="Normal">    RETURN(our);</Text-field>
<Text-field prompt="&gt; " style="Maple Input" layout="Normal">end:</Text-field>
<Text-field prompt="&gt; " style="Maple Input" layout="Normal">nfractionalpart:=proc(n,p,q) local our;</Text-field>
<Text-field prompt="&gt; " style="Maple Input" layout="Normal">    if  type(n,rational) then our:=fractionalpart(p*n/q)</Text-field>
<Text-field prompt="&gt; " style="Maple Input" layout="Normal">    else our:=1/q*ourmod(p,q,n);</Text-field>
<Text-field prompt="&gt; " style="Maple Input" layout="Normal">    fi;</Text-field>
<Text-field prompt="&gt; " style="Maple Input" layout="Normal">    our;</Text-field>
<Text-field prompt="&gt; " style="Maple Input" layout="Normal">end:</Text-field>
<Text-field prompt="&gt; " style="Maple Input" layout="Normal"></Text-field>
<Text-field prompt="&gt; " style="Maple Input" layout="Normal">ourmodreal:=proc(p,q,t) local our,T;</Text-field>
<Text-field prompt="&gt; " style="Maple Input" layout="Normal">    if type(t,integer) then our:=modp(t*p,q);fi;</Text-field>
<Text-field prompt="&gt; " style="Maple Input" layout="Normal">    if t=0 or p=0 then our:=0;</Text-field>
<Text-field prompt="&gt; " style="Maple Input" layout="Normal">    else our:=q*frac(p*t/q);</Text-field>
<Text-field prompt="&gt; " style="Maple Input" layout="Normal">    fi;</Text-field>
<Text-field prompt="&gt; " style="Maple Input" layout="Normal">    our;</Text-field>
<Text-field prompt="&gt; " style="Maple Input" layout="Normal">end:</Text-field>
<Text-field prompt="&gt; " style="Maple Input" layout="Normal">nfractionalpartreal:=proc(n,p,q) local our;</Text-field>
<Text-field prompt="&gt; " style="Maple Input" layout="Normal">    if  type(n,rational) then our:=fractionalpart(p*n/q)</Text-field>
<Text-field prompt="&gt; " style="Maple Input" layout="Normal">    else our:=1/q*ourmodreal(p,q,n);</Text-field>
<Text-field prompt="&gt; " style="Maple Input" layout="Normal">    fi;</Text-field>
<Text-field prompt="&gt; " style="Maple Input" layout="Normal">    our;</Text-field>
<Text-field prompt="&gt; " style="Maple Input" layout="Normal">end:</Text-field>
<Text-field prompt="&gt; " style="Maple Input" layout="Normal">volume_ISpace:=proc(W,ISpace) local P,M,H,MM,output;</Text-field>
<Text-field prompt="&gt; " style="Maple Input" layout="Normal">    if ISpace=[] then output:=1;</Text-field>
<Text-field prompt="&gt; " style="Maple Input" layout="Normal">    else P:=matrix([seq(W[ISpace[i]],i=1..nops(ISpace))]);</Text-field>
<Text-field prompt="&gt; " style="Maple Input" layout="Normal">        M:=transpose(matrix(P));</Text-field>
<Text-field prompt="&gt; " style="Maple Input" layout="Normal">        H:=ihermite(M);</Text-field>
<Text-field prompt="&gt; " style="Maple Input" layout="Normal">        MM:=matrix([seq(row(H,i),i=1..nops(ISpace))]);</Text-field>
<Text-field prompt="&gt; " style="Maple Input" layout="Normal">        output:=det(MM);</Text-field>
<Text-field prompt="&gt; " style="Maple Input" layout="Normal">    fi;</Text-field>
<Text-field prompt="&gt; " style="Maple Input" layout="Normal">    output;</Text-field>
<Text-field prompt="&gt; " style="Maple Input" layout="Normal">end:</Text-field>
<Text-field prompt="&gt; " style="Maple Input" layout="Normal">functionIa:=proc(s,W,ISpace,xi)</Text-field>
<Text-field prompt="&gt; " style="Maple Input" layout="Normal">local s_on_ISpace,d,T,i,y,r,out;</Text-field>
<Text-field prompt="&gt; " style="Maple Input" layout="Normal">    d:=nops(W);</Text-field>
<Text-field prompt="&gt; " style="Maple Input" layout="Normal">    s_on_ISpace:=s_ISpace(s,W,ISpace);</Text-field>
<Text-field prompt="&gt; " style="Maple Input" layout="Normal">    if nops(ISpace)=0</Text-field>
<Text-field prompt="&gt; " style="Maple Input" layout="Normal">    then out:=[1,1];</Text-field>
<Text-field prompt="&gt; " style="Maple Input" layout="Normal">    else</Text-field>
<Text-field prompt="&gt; " style="Maple Input" layout="Normal">        r:=volume_ISpace(W,ISpace);</Text-field>
<Text-field prompt="&gt; " style="Maple Input" layout="Normal">        T:=1;</Text-field>
<Text-field prompt="&gt; " style="Maple Input" layout="Normal">        for i from 1 to nops(ISpace) do</Text-field>
<Text-field prompt="&gt; " style="Maple Input" layout="Normal">            y:=add(W[ISpace[i]][j]*xi[j],j=1..d);</Text-field>
<Text-field prompt="&gt; " style="Maple Input" layout="Normal">            T:=T*y;</Text-field>
<Text-field prompt="&gt; " style="Maple Input" layout="Normal">        od;</Text-field>
<Text-field prompt="&gt; " style="Maple Input" layout="Normal">        T:=(-1)^(nops(ISpace))*T;</Text-field>
<Text-field prompt="&gt; " style="Maple Input" layout="Normal">        out:=[r*EXP(add(s_on_ISpace[m]*xi[m],m=1..d)),T];</Text-field>
<Text-field prompt="&gt; " style="Maple Input" layout="Normal">    fi;</Text-field>
<Text-field prompt="&gt; " style="Maple Input" layout="Normal">    out;</Text-field>
<Text-field prompt="&gt; " style="Maple Input" layout="Normal">end:</Text-field>
<Text-field prompt="&gt; " style="Maple Input" layout="Normal"></Text-field>
<Text-field prompt="&gt; " style="Maple Input" layout="Normal"></Text-field>
<Text-field prompt="&gt; " style="Maple Input" layout="Normal">functionIb:=proc(s,W,ISpace,xi)</Text-field>
<Text-field prompt="&gt; " style="Maple Input" layout="Normal">local d,T,i,y,r,out;</Text-field>
<Text-field prompt="&gt; " style="Maple Input" layout="Normal">    d:=nops(W);</Text-field>
<Text-field prompt="&gt; " style="Maple Input" layout="Normal">    if nops(ISpace)=0</Text-field>
<Text-field prompt="&gt; " style="Maple Input" layout="Normal">    then out:=[1,1];</Text-field>
<Text-field prompt="&gt; " style="Maple Input" layout="Normal">    else</Text-field>
<Text-field prompt="&gt; " style="Maple Input" layout="Normal">        r:=volume_ISpace(W,ISpace);</Text-field>
<Text-field prompt="&gt; " style="Maple Input" layout="Normal">        T:=1;</Text-field>
<Text-field prompt="&gt; " style="Maple Input" layout="Normal">        for i from 1 to nops(ISpace) do</Text-field>
<Text-field prompt="&gt; " style="Maple Input" layout="Normal">            y:=add(W[ISpace[i]][j]*xi[j],j=1..d);</Text-field>
<Text-field prompt="&gt; " style="Maple Input" layout="Normal">            T:=T*y;</Text-field>
<Text-field prompt="&gt; " style="Maple Input" layout="Normal">        od;</Text-field>
<Text-field prompt="&gt; " style="Maple Input" layout="Normal">        T:=(-1)^(nops(ISpace))*T;</Text-field>
<Text-field prompt="&gt; " style="Maple Input" layout="Normal">        out:=[r,T];</Text-field>
<Text-field prompt="&gt; " style="Maple Input" layout="Normal">    fi;</Text-field>
<Text-field prompt="&gt; " style="Maple Input" layout="Normal">    out;</Text-field>
<Text-field prompt="&gt; " style="Maple Input" layout="Normal">end:</Text-field>
<Text-field prompt="&gt; " style="Maple Input" layout="Normal">prod_Todd:=proc(z,W,xi) local d,E,i,T,y;</Text-field>
<Text-field prompt="&gt; " style="Maple Input" layout="Normal">    d:=nops(W);</Text-field>
<Text-field prompt="&gt; " style="Maple Input" layout="Normal">    T:=1;</Text-field>
<Text-field prompt="&gt; " style="Maple Input" layout="Normal">    for i from 1 to d do</Text-field>
<Text-field prompt="&gt; " style="Maple Input" layout="Normal">        y:=add(W[i][j]*xi[j],j=1..nops(W[i]));</Text-field>
<Text-field prompt="&gt; " style="Maple Input" layout="Normal">        T:=T*TODD(z[i],y);</Text-field>
<Text-field prompt="&gt; " style="Maple Input" layout="Normal">    od;</Text-field>
<Text-field prompt="&gt; " style="Maple Input" layout="Normal">    T;</Text-field>
<Text-field prompt="&gt; " style="Maple Input" layout="Normal">end:</Text-field>
<Text-field prompt="&gt; " style="Maple Input" layout="Normal">functionS:=proc(z,W,xi) local P,Q,y,i;</Text-field>
<Text-field prompt="&gt; " style="Maple Input" layout="Normal">    P:=prod_Todd(z,W,xi);</Text-field>
<Text-field prompt="&gt; " style="Maple Input" layout="Normal">    Q:=1;</Text-field>
<Text-field prompt="&gt; " style="Maple Input" layout="Normal">    for i from 1 to nops(W) do</Text-field>
<Text-field prompt="&gt; " style="Maple Input" layout="Normal">#ASSERT(nops(W[i])=nops(x),&quot;W[i], x need to be of the same length&quot;);</Text-field>
<Text-field prompt="&gt; " style="Maple Input" layout="Normal">        y:=add(W[i][j]*xi[j],j=1..nops(W[i]));</Text-field>
<Text-field prompt="&gt; " style="Maple Input" layout="Normal">        Q:=Q*y;</Text-field>
<Text-field prompt="&gt; " style="Maple Input" layout="Normal">    od;</Text-field>
<Text-field prompt="&gt; " style="Maple Input" layout="Normal">    [P,Q];</Text-field>
<Text-field prompt="&gt; " style="Maple Input" layout="Normal">end:</Text-field>
<Text-field prompt="&gt; " style="Maple Input" layout="Normal"></Text-field>
<Text-field prompt="&gt; " style="Maple Input" layout="Normal">changeofcoordinates:=proc(W,Cspace,ProjLattice,xi) local H,newxi,i,d;</Text-field>
<Text-field prompt="&gt; " style="Maple Input" layout="Normal">    H:=ProjLattice;</Text-field>
<Text-field prompt="&gt; " style="Maple Input" layout="Normal">    d:=nops(W[1]);</Text-field>
<Text-field prompt="&gt; " style="Maple Input" layout="Normal">    newxi:=[];</Text-field>
<Text-field prompt="&gt; " style="Maple Input" layout="Normal">    for i from 1 to nops(H) do</Text-field>
<Text-field prompt="&gt; " style="Maple Input" layout="Normal">        newxi:=[op(newxi),add(xi[j]*H[i][j],j=1..d)];</Text-field>
<Text-field prompt="&gt; " style="Maple Input" layout="Normal">    od;</Text-field>
<Text-field prompt="&gt; " style="Maple Input" layout="Normal">    newxi;</Text-field>
<Text-field prompt="&gt; " style="Maple Input" layout="Normal">end:</Text-field>
<Text-field prompt="&gt; " style="Maple Input" layout="Normal">#changeofcoordinates([[1,0,0],[1,1,2],[0,5,1]],[1,2],...,xi);</Text-field>
<Text-field prompt="&gt; " style="Maple Input" layout="Normal"></Text-field>
<Text-field prompt="&gt; " style="Maple Input" layout="Normal"># THE FUNCTION (S^Ispace) for a cone. Here we sum  the integrals of e^{xi,x}</Text-field>
<Text-field prompt="&gt; " style="Maple Input" layout="Normal">#  on slices of the cone</Text-field>
<Text-field prompt="&gt; " style="Maple Input" layout="Normal"># parallel to  L generated by w_i with i in Ispace.</Text-field>
<Text-field prompt="&gt; " style="Maple Input" layout="Normal"># WE GIVE THE TWO FORMULAE A) and B)</Text-field>
<Text-field prompt="&gt; " style="Maple Input" layout="Normal"># THESE ARE  THE MAIN  TECHNICAL PROCEDURES.</Text-field>
<Text-field prompt="&gt; " style="Maple Input" layout="Normal">#</Text-field>
<Text-field prompt="&gt; " style="Maple Input" layout="Normal">#</Text-field>
<Text-field prompt="&gt; " style="Maple Input" layout="Normal">#</Text-field>
<Text-field prompt="&gt; " style="Maple Input" layout="Normal"># Input: s a vector in Q^d,  or a symbolic variable ; BUT THEN IT HAS TO BE ENTERED AS A LIST OF  d SYMBOLIC VARIABLES</Text-field>
<Text-field prompt="&gt; " style="Maple Input" layout="Normal"># s:=[s1,s2,...,sd]; W a cone in Z^d, Ispace a subset of [1,...,d]</Text-field>
<Text-field prompt="&gt; " style="Maple Input" layout="Normal"># xi a list of lenght d  of variable (or xi);</Text-field>
<Text-field prompt="&gt; " style="Maple Input" layout="Normal"></Text-field>
<Text-field prompt="&gt; " style="Maple Input" layout="Normal"># The output is a function of xi[i].</Text-field>
<Text-field prompt="&gt; " style="Maple Input" layout="Normal">#</Text-field>
<Text-field prompt="&gt; " style="Maple Input" layout="Normal"># The subspace $L$ where we integrate is the following face of W: L is the linear span of</Text-field>
<Text-field prompt="&gt; " style="Maple Input" layout="Normal"># &lt;w[j]&gt;, with j running of Ispace. (thus Ispace should be &quot;big&quot;)</Text-field>
<Text-field prompt="&gt; " style="Maple Input" layout="Normal">#</Text-field>
<Text-field prompt="&gt; " style="Maple Input" layout="Normal"># Here we take out a function of s, ceil</Text-field>
<Text-field prompt="&gt; " style="Maple Input" layout="Normal"># EXAMPLE: S_Ispace_Coneformulaa([s1,s2],[[1,0],[1,2]],[1],xi)-&gt;  -TODD(ceil(s2), (1/2)*xi[1]+xi[2])*EXP((s1-(1/2)*s2)*#xi[1])/(((1/2)*xi[1]+xi[2])*xi[1]);</Text-field>
<Text-field prompt="&gt; " style="Maple Input" layout="Normal">S_Ispace_Coneformulaa:=proc(s,W,ISpace,xi) local i,ss,uni_cones,function_on_Cspace,function_on_ISpace,W_projected,WW,WWW,signuni,signL,j,Cspace,out1,out2,s_in_cone_coord,s_Cspace_in_cone_coord,s_prime_Cspace,M,newxi,dimL,g,testrank,newP,</Text-field>
<Text-field prompt="&gt; " style="Maple Input" layout="Normal">    s_Cspace_in_lattice_coord,news,</Text-field>
<Text-field prompt="&gt; " style="Maple Input" layout="Normal">    ProjLattice;</Text-field>
<Text-field prompt="&gt; " style="Maple Input" layout="Normal">    Cspace:=ComplementList(ISpace,nops(W));</Text-field>
<Text-field prompt="&gt; " style="Maple Input" layout="Normal">    ProjLattice := projectedlattice(W,Cspace);</Text-field>
<Text-field prompt="&gt; " style="Maple Input" layout="Normal">    s_Cspace_in_lattice_coord:=projectedvertexinbasislattice(W,Cspace,ProjLattice,s);</Text-field>
<Text-field prompt="&gt; " style="Maple Input" layout="Normal">    function_on_ISpace:=functionIa(s,W,ISpace,xi);</Text-field>
<Text-field prompt="&gt; " style="Maple Input" layout="Normal">#from here express in terms of the basis lattice for projected cone.</Text-field>
<Text-field prompt="&gt; " style="Maple Input" layout="Normal">    W_projected:=projectedconeinbasislattice(W,Cspace,ProjLattice):</Text-field>
<Text-field prompt="&gt; " style="Maple Input" layout="Normal">    if W_projected=[] then</Text-field>
<Text-field prompt="&gt; " style="Maple Input" layout="Normal">        out1:=function_on_ISpace[1]/function_on_ISpace[2];</Text-field>
<Text-field prompt="&gt; " style="Maple Input" layout="Normal">    else</Text-field>
<Text-field prompt="&gt; " style="Maple Input" layout="Normal">        newxi:=changeofcoordinates(W,Cspace,ProjLattice,xi);</Text-field>
<Text-field prompt="&gt; " style="Maple Input" layout="Normal">        uni_cones:=cone_dec(W_projected);</Text-field>
<Text-field prompt="&gt; " style="Maple Input" layout="Normal">        out1:=0;</Text-field>
<Text-field prompt="&gt; " style="Maple Input" layout="Normal">        for j from 1 to nops(uni_cones) do</Text-field>
<Text-field prompt="&gt; " style="Maple Input" layout="Normal">            WWW:=uni_cones[j][3];</Text-field>
<Text-field prompt="&gt; " style="Maple Input" layout="Normal">            signuni:=uni_cones[j][1];</Text-field>
<Text-field prompt="&gt; " style="Maple Input" layout="Normal">            ASSERT(abs(uni_cones[j][2])=1, &quot;decomposition not unimodular&quot;);</Text-field>
<Text-field prompt="&gt; " style="Maple Input" layout="Normal">            newP:=MatrixInverse(Transpose(Matrix(WWW)));</Text-field>
<Text-field prompt="&gt; " style="Maple Input" layout="Normal">            news:=convert(Multiply(newP,Vector(s_Cspace_in_lattice_coord)),list); ##print(news);</Text-field>
<Text-field prompt="&gt; " style="Maple Input" layout="Normal">            s_prime_Cspace:=[seq(ourceil(news[f]),f=1..nops(news))];</Text-field>
<Text-field prompt="&gt; " style="Maple Input" layout="Normal">            function_on_Cspace:=functionS(s_prime_Cspace,WWW,newxi);</Text-field>
<Text-field prompt="&gt; " style="Maple Input" layout="Normal">            out1:=out1+signuni*function_on_Cspace[1]/function_on_Cspace[2]*function_on_ISpace[1]/function_on_ISpace[2];</Text-field>
<Text-field prompt="&gt; " style="Maple Input" layout="Normal">        od:</Text-field>
<Text-field prompt="&gt; " style="Maple Input" layout="Normal">    fi;</Text-field>
<Text-field prompt="&gt; " style="Maple Input" layout="Normal">    out1;</Text-field>
<Text-field prompt="&gt; " style="Maple Input" layout="Normal">end:</Text-field>
<Text-field prompt="&gt; " style="Maple Input" layout="Normal"></Text-field>
<Text-field prompt="&gt; " style="Maple Input" layout="Normal"></Text-field>
<Text-field prompt="&gt; " style="Maple Input" layout="Normal"># Input: s a vector in Q^d,  or a symbolic variable ; BUT THEN IT HAS TO BE ENTERED AS A LIST OF  d SYMBOLIC VARIABLES</Text-field>
<Text-field prompt="&gt; " style="Maple Input" layout="Normal"># s:=[s1,s2,...,sd]; W a cone in Z^d, Ispace a subset of [1,...,d]</Text-field>
<Text-field prompt="&gt; " style="Maple Input" layout="Normal"># xi a list of lenght d  of variable (or xi);</Text-field>
<Text-field prompt="&gt; " style="Maple Input" layout="Normal"></Text-field>
<Text-field prompt="&gt; " style="Maple Input" layout="Normal"># The output is a function of xi[i].</Text-field>
<Text-field prompt="&gt; " style="Maple Input" layout="Normal">#</Text-field>
<Text-field prompt="&gt; " style="Maple Input" layout="Normal"># The subspace $L$ where we integrate is the following face of W: L is the linear span of</Text-field>
<Text-field prompt="&gt; " style="Maple Input" layout="Normal"># &lt;w[j]&gt;, with j running of Ispace. (thus Ispace should be &quot;big&quot;)</Text-field>
<Text-field prompt="&gt; " style="Maple Input" layout="Normal">#</Text-field>
<Text-field prompt="&gt; " style="Maple Input" layout="Normal"># Here we take out a function of s, fractionalpart</Text-field>
<Text-field prompt="&gt; " style="Maple Input" layout="Normal">#</Text-field>
<Text-field prompt="&gt; " style="Maple Input" layout="Normal">S_Ispace_Coneformulab:=proc(s,W,ISpace,xi) local i,ss,uni_cones,function_on_Cspace,function_on_ISpace,W_projected,WW,WWW,signuni,signL,j,Cspace,out1,out2,s_in_cone_coord,s_Cspace_in_cone_coord,s_small_move,M,newxi,dimL,g,testrank,newP,</Text-field>
<Text-field prompt="&gt; " style="Maple Input" layout="Normal">    s_Cspace_in_lattice_coord,news,</Text-field>
<Text-field prompt="&gt; " style="Maple Input" layout="Normal">    ProjLattice;</Text-field>
<Text-field prompt="&gt; " style="Maple Input" layout="Normal">    Cspace:=ComplementList(ISpace,nops(W));</Text-field>
<Text-field prompt="&gt; " style="Maple Input" layout="Normal">    ProjLattice := projectedlattice(W,Cspace);</Text-field>
<Text-field prompt="&gt; " style="Maple Input" layout="Normal">    s_Cspace_in_lattice_coord:=projectedvertexinbasislattice(W,Cspace,ProjLattice,s);</Text-field>
<Text-field prompt="&gt; " style="Maple Input" layout="Normal">    function_on_ISpace:=functionIb(s,W,ISpace,xi);</Text-field>
<Text-field prompt="&gt; " style="Maple Input" layout="Normal">#from here express in terms of the basis lattice for projected cone.</Text-field>
<Text-field prompt="&gt; " style="Maple Input" layout="Normal">    W_projected:=projectedconeinbasislattice(W,Cspace,ProjLattice):</Text-field>
<Text-field prompt="&gt; " style="Maple Input" layout="Normal">    if W_projected=[] then</Text-field>
<Text-field prompt="&gt; " style="Maple Input" layout="Normal">        out1:=function_on_ISpace[1]/function_on_ISpace[2];</Text-field>
<Text-field prompt="&gt; " style="Maple Input" layout="Normal">    else</Text-field>
<Text-field prompt="&gt; " style="Maple Input" layout="Normal">        newxi:=changeofcoordinates(W,Cspace,ProjLattice,xi);</Text-field>
<Text-field prompt="&gt; " style="Maple Input" layout="Normal">        uni_cones:=cone_dec(W_projected);</Text-field>
<Text-field prompt="&gt; " style="Maple Input" layout="Normal">        out1:=0;</Text-field>
<Text-field prompt="&gt; " style="Maple Input" layout="Normal">        for j from 1 to nops(uni_cones) do</Text-field>
<Text-field prompt="&gt; " style="Maple Input" layout="Normal">            WWW:=uni_cones[j][3];</Text-field>
<Text-field prompt="&gt; " style="Maple Input" layout="Normal">            signuni:=uni_cones[j][1];</Text-field>
<Text-field prompt="&gt; " style="Maple Input" layout="Normal">            ASSERT(abs(uni_cones[j][2])=1, &quot;decomposition not unimodular&quot;);</Text-field>
<Text-field prompt="&gt; " style="Maple Input" layout="Normal">            newP:=MatrixInverse(Transpose(Matrix(WWW)));</Text-field>
<Text-field prompt="&gt; " style="Maple Input" layout="Normal">            news:=convert(Multiply(newP,Vector(s_Cspace_in_lattice_coord)),list); ##print(news);</Text-field>
<Text-field prompt="&gt; " style="Maple Input" layout="Normal">            s_small_move:=[seq(fractionalpart(-news[f]),f=1..nops(news))];</Text-field>
<Text-field prompt="&gt; " style="Maple Input" layout="Normal">            function_on_Cspace:=functionS(s_small_move,WWW,newxi);</Text-field>
<Text-field prompt="&gt; " style="Maple Input" layout="Normal">            out1:=out1+signuni*function_on_Cspace[1]/function_on_Cspace[2]*function_on_ISpace[1]/function_on_ISpace[2];</Text-field>
<Text-field prompt="&gt; " style="Maple Input" layout="Normal">        od:</Text-field>
<Text-field prompt="&gt; " style="Maple Input" layout="Normal">    fi;</Text-field>
<Text-field prompt="&gt; " style="Maple Input" layout="Normal">    EXP(add(s[i]*xi[i],i=1..nops(W)))*out1;</Text-field>
<Text-field prompt="&gt; " style="Maple Input" layout="Normal">end:</Text-field>
<Text-field prompt="&gt; " style="Maple Input" layout="Normal"></Text-field>
<Text-field prompt="&gt; " style="Maple Input" layout="Normal"></Text-field>
<Text-field prompt="&gt; " style="Maple Input" layout="Normal">S_Ispace_Coneformulab([s1,s2],[[1,0],[1,2]],[1],xi);</Text-field>
<Text-field prompt="&gt; " style="Maple Input" layout="Normal">#</Text-field>
<Text-field prompt="&gt; " style="Maple Input" layout="Normal"># WE WILL NOT USE THE FOLLOWING  PROCEDURE, AS OUR CHOICE OF REGULAR VECTOR WILL BE DONE WITH A RANDOM PROCEDURE.</Text-field>
<Text-field prompt="&gt; " style="Maple Input" layout="Normal"># BUT WE SHOULD WHEN DETERMINING DETERMINISTICALLY A REGULAR VECTOR.</Text-field>
<Text-field prompt="&gt; " style="Maple Input" layout="Normal">#</Text-field>
<Text-field prompt="&gt; " style="Maple Input" layout="Normal">#</Text-field>
<Text-field prompt="&gt; " style="Maple Input" layout="Normal"># Input: W a cone in Z^d, Cspace  a subset of [1,2,..,d]  ,x a variable.</Text-field>
<Text-field prompt="&gt; " style="Maple Input" layout="Normal"># Output: a list of linear forms.</Text-field>
<Text-field prompt="&gt; " style="Maple Input" layout="Normal">#  Math: this is  the forms in denominator of the   function S_Ispace_Cone(W,Cspace,x). In practice we will not use this procedure.</Text-field>
<Text-field prompt="&gt; " style="Maple Input" layout="Normal"># This is useful to determine a &quot;deterministic regular vector&quot;, but we will plug a random regular vector;</Text-field>
<Text-field prompt="&gt; " style="Maple Input" layout="Normal"># EXAMPLE linindenom([[1,0],[1,2]],[1,2])-&gt;{x[1], x[2], x[1]+2*x[2]};</Text-field>
<Text-field prompt="&gt; " style="Maple Input" layout="Normal">#</Text-field>
<Text-field prompt="&gt; " style="Maple Input" layout="Normal"></Text-field>
<Text-field prompt="&gt; " style="Maple Input" layout="Normal">linindenom:=proc(W,Cspace) local YY,i,ISpace,g,WW,newx,d,a,z,cc,</Text-field>
<Text-field prompt="&gt; " style="Maple Input" layout="Normal">    WW_projected,uni_cones,t,cleanYY,r,ProjLattice;</Text-field>
<Text-field prompt="&gt; " style="Maple Input" layout="Normal">    d:=nops(W);</Text-field>
<Text-field prompt="&gt; " style="Maple Input" layout="Normal">    YY:={};</Text-field>
<Text-field prompt="&gt; " style="Maple Input" layout="Normal">    ProjLattice := projectedlattice(W,Cspace);</Text-field>
<Text-field prompt="&gt; " style="Maple Input" layout="Normal">    WW_projected:=projectedconeinbasislattice(W,Cspace,ProjLattice):</Text-field>
<Text-field prompt="&gt; " style="Maple Input" layout="Normal">###print(WW_projected);</Text-field>
<Text-field prompt="&gt; " style="Maple Input" layout="Normal">    newx:=changeofcoordinates(W,Cspace,ProjLattice,x);</Text-field>
<Text-field prompt="&gt; " style="Maple Input" layout="Normal">    uni_cones:=cone_dec(WW_projected);</Text-field>
<Text-field prompt="&gt; " style="Maple Input" layout="Normal">    for z from 1 to nops(uni_cones) do</Text-field>
<Text-field prompt="&gt; " style="Maple Input" layout="Normal">        cc:=uni_cones[z][3];</Text-field>
<Text-field prompt="&gt; " style="Maple Input" layout="Normal">        for t from 1 to nops(cc) do</Text-field>
<Text-field prompt="&gt; " style="Maple Input" layout="Normal">            YY:={op(YY), add(cc[t][s]*newx[s],s=1..nops(newx))}</Text-field>
<Text-field prompt="&gt; " style="Maple Input" layout="Normal">        od;</Text-field>
<Text-field prompt="&gt; " style="Maple Input" layout="Normal"></Text-field>
<Text-field prompt="&gt; " style="Maple Input" layout="Normal">    od;</Text-field>
<Text-field prompt="&gt; " style="Maple Input" layout="Normal">    cleanYY:={};</Text-field>
<Text-field prompt="&gt; " style="Maple Input" layout="Normal">    for r from 1 to nops(YY) do</Text-field>
<Text-field prompt="&gt; " style="Maple Input" layout="Normal">        if member(-YY[r],cleanYY)=false then</Text-field>
<Text-field prompt="&gt; " style="Maple Input" layout="Normal">            cleanYY:={op(cleanYY),YY[r]}</Text-field>
<Text-field prompt="&gt; " style="Maple Input" layout="Normal">        fi;</Text-field>
<Text-field prompt="&gt; " style="Maple Input" layout="Normal">    od;</Text-field>
<Text-field prompt="&gt; " style="Maple Input" layout="Normal">    cleanYY;</Text-field>
<Text-field prompt="&gt; " style="Maple Input" layout="Normal">end:</Text-field>
<Text-field prompt="&gt; " style="Maple Input" layout="Normal"></Text-field>
<Text-field prompt="&gt; " style="Maple Input" layout="Normal"></Text-field>
<Text-field prompt="&gt; " style="Maple Input" layout="Normal">#linindenom([[1,0],[1,2]],[1,2]);</Text-field>
<Text-field prompt="&gt; " style="Maple Input" layout="Normal">#  Approximation for a cone;</Text-field>
<Text-field prompt="&gt; " style="Maple Input" layout="Normal">#</Text-field>
<Text-field prompt="&gt; " style="Maple Input" layout="Normal">#</Text-field>
<Text-field prompt="&gt; " style="Maple Input" layout="Normal">#</Text-field>
<Text-field prompt="&gt; " style="Maple Input" layout="Normal">#</Text-field>
<Text-field prompt="&gt; " style="Maple Input" layout="Normal"># Input:  s a vector in Q^d,  or a symbolic variable (but has to be entered as a list of d symbolic variables,</Text-field>
<Text-field prompt="&gt; " style="Maple Input" layout="Normal"># W a cone, order  an integer;</Text-field>
<Text-field prompt="&gt; " style="Maple Input" layout="Normal"># xi a list of variables.</Text-field>
<Text-field prompt="&gt; " style="Maple Input" layout="Normal"># Output a function f(xi);</Text-field>
<Text-field prompt="&gt; " style="Maple Input" layout="Normal"># Math:  let C=s+W;  The output is a function f(xi) such that</Text-field>
<Text-field prompt="&gt; " style="Maple Input" layout="Normal"># the beginning of the Laurent series of f(t*xi) under dilation should  coinciding with S_C(t*xi) for order+1</Text-field>
<Text-field prompt="&gt; " style="Maple Input" layout="Normal">#  terms:  given by formula a (with ceil functions)</Text-field>
<Text-field prompt="&gt; " style="Maple Input" layout="Normal"></Text-field>
<Text-field prompt="&gt; " style="Maple Input" layout="Normal"># EXAMPLES ARE GIVEN AFTER;</Text-field>
<Text-field prompt="&gt; " style="Maple Input" layout="Normal"></Text-field>
<Text-field prompt="&gt; " style="Maple Input" layout="Normal">approx_Cone_formulaa:=proc(s,W,order,xi) local output,d,j,C,a,K,KK,cc,P;</Text-field>
<Text-field prompt="&gt; " style="Maple Input" layout="Normal">    output:=0; P:=order;</Text-field>
<Text-field prompt="&gt; " style="Maple Input" layout="Normal">    d:=nops(W);</Text-field>
<Text-field prompt="&gt; " style="Maple Input" layout="Normal">    if P=d then</Text-field>
<Text-field prompt="&gt; " style="Maple Input" layout="Normal">        output:=S_Ispace_Coneformulaa(s,W,[],xi) ;</Text-field>
<Text-field prompt="&gt; " style="Maple Input" layout="Normal">    else</Text-field>
<Text-field prompt="&gt; " style="Maple Input" layout="Normal">        for j from 0 to P do</Text-field>
<Text-field prompt="&gt; " style="Maple Input" layout="Normal">            C:=choose(d,j);</Text-field>
<Text-field prompt="&gt; " style="Maple Input" layout="Normal">            cc[j]:=(-1)^(P-j)*binomial(d-j-1,d-P-1);</Text-field>
<Text-field prompt="&gt; " style="Maple Input" layout="Normal">            for a from 1 to nops(C) do</Text-field>
<Text-field prompt="&gt; " style="Maple Input" layout="Normal">                K:=C[a]; KK:=ComplementList(K,nops(W));</Text-field>
<Text-field prompt="&gt; " style="Maple Input" layout="Normal">                output:=output+cc[j]*S_Ispace_Coneformulaa(s,W,KK,xi) ;</Text-field>
<Text-field prompt="&gt; " style="Maple Input" layout="Normal">            od;</Text-field>
<Text-field prompt="&gt; " style="Maple Input" layout="Normal">        od:</Text-field>
<Text-field prompt="&gt; " style="Maple Input" layout="Normal">    fi;</Text-field>
<Text-field prompt="&gt; " style="Maple Input" layout="Normal">    output;</Text-field>
<Text-field prompt="&gt; " style="Maple Input" layout="Normal">end:</Text-field>
<Text-field prompt="&gt; " style="Maple Input" layout="Normal">#approx_Cone_formulaa([s,1/2], [[1,0],[1,2]],2,xi);</Text-field>
<Text-field prompt="&gt; " style="Maple Input" layout="Normal">#approx_Cone_formulaa([s1,s2], [[1,0],[1,2]],1,xi);</Text-field>
<Text-field prompt="&gt; " style="Maple Input" layout="Normal">#</Text-field>
<Text-field prompt="&gt; " style="Maple Input" layout="Normal">#</Text-field>
<Text-field prompt="&gt; " style="Maple Input" layout="Normal"># Input:  s a vector in Q^d,  or a symbolic variable (but has to be entered as a list of d symbolic variables,</Text-field>
<Text-field prompt="&gt; " style="Maple Input" layout="Normal"># W a cone, order  an integer;</Text-field>
<Text-field prompt="&gt; " style="Maple Input" layout="Normal"># xi a list of variables.</Text-field>
<Text-field prompt="&gt; " style="Maple Input" layout="Normal"># Output a function f(xi);</Text-field>
<Text-field prompt="&gt; " style="Maple Input" layout="Normal"># Math:  let C=s+W; A function f(xi) such that</Text-field>
<Text-field prompt="&gt; " style="Maple Input" layout="Normal"># the beginning of the Laurent series of f(t*xi) under dilation should  coinciding with S_C(t*xi) for order+1</Text-field>
<Text-field prompt="&gt; " style="Maple Input" layout="Normal">#  terms:  given by formula b (with fractionalparts functions)</Text-field>
<Text-field prompt="&gt; " style="Maple Input" layout="Normal"></Text-field>
<Text-field prompt="&gt; " style="Maple Input" layout="Normal"># EXAMPLES ARE GIVEN AFTER;</Text-field>
<Text-field prompt="&gt; " style="Maple Input" layout="Normal"></Text-field>
<Text-field prompt="&gt; " style="Maple Input" layout="Normal">approx_Cone_formulab:=proc(s,W,order,xi) local output,d,j,C,a,K,KK,cc,P;</Text-field>
<Text-field prompt="&gt; " style="Maple Input" layout="Normal">    output:=0; P:=order;</Text-field>
<Text-field prompt="&gt; " style="Maple Input" layout="Normal">    d:=nops(W);</Text-field>
<Text-field prompt="&gt; " style="Maple Input" layout="Normal">    if P=d then</Text-field>
<Text-field prompt="&gt; " style="Maple Input" layout="Normal">        output:=S_Ispace_Coneformulab(s,W,[],xi) ;</Text-field>
<Text-field prompt="&gt; " style="Maple Input" layout="Normal">    else</Text-field>
<Text-field prompt="&gt; " style="Maple Input" layout="Normal">        for j from 0 to P do</Text-field>
<Text-field prompt="&gt; " style="Maple Input" layout="Normal">            C:=choose(d,j);</Text-field>
<Text-field prompt="&gt; " style="Maple Input" layout="Normal">            cc[j]:=(-1)^(P-j)*binomial(d-j-1,d-P-1);</Text-field>
<Text-field prompt="&gt; " style="Maple Input" layout="Normal">            for a from 1 to nops(C) do</Text-field>
<Text-field prompt="&gt; " style="Maple Input" layout="Normal">                K:=C[a]; KK:=ComplementList(K,nops(W));</Text-field>
<Text-field prompt="&gt; " style="Maple Input" layout="Normal">                output:=output+cc[j]*S_Ispace_Coneformulab(s,W,KK,xi) ;</Text-field>
<Text-field prompt="&gt; " style="Maple Input" layout="Normal">            od;</Text-field>
<Text-field prompt="&gt; " style="Maple Input" layout="Normal">        od:</Text-field>
<Text-field prompt="&gt; " style="Maple Input" layout="Normal">    fi;</Text-field>
<Text-field prompt="&gt; " style="Maple Input" layout="Normal">    output;</Text-field>
<Text-field prompt="&gt; " style="Maple Input" layout="Normal">end:</Text-field>
<Text-field prompt="&gt; " style="Maple Input" layout="Normal">#approx_Cone_formulab([1/2,1/2], [[1,0],[1,2]],1,xi);</Text-field>
<Text-field prompt="&gt; " style="Maple Input" layout="Normal">#approx_Cone_formulab([s1,s2], [[1,0],[1,2]],1,xi);</Text-field>
<Text-field prompt="&gt; " style="Maple Input" layout="Normal"># ADDING THE CONES APPROXIMATIONS FOR A RATIONAL SIMPLEX;</Text-field>
<Text-field prompt="&gt; " style="Maple Input" layout="Normal"># Input: A SIMPLEX entered as a list of d+1 rational vectors in R^d; order is an integer, xi is a variable.</Text-field>
<Text-field prompt="&gt; " style="Maple Input" layout="Normal"># xi can also be entered as a numeric list of lenght d, but there can be then an error message (division by zero).</Text-field>
<Text-field prompt="&gt; " style="Maple Input" layout="Normal"># OUTPUT: a function of xi;</Text-field>
<Text-field prompt="&gt; " style="Maple Input" layout="Normal"></Text-field>
<Text-field prompt="&gt; " style="Maple Input" layout="Normal">#</Text-field>
<Text-field prompt="&gt; " style="Maple Input" layout="Normal"># EXAMPLES ARE GIVEN AFTER;</Text-field>
<Text-field prompt="&gt; " style="Maple Input" layout="Normal">#</Text-field>
<Text-field prompt="&gt; " style="Maple Input" layout="Normal">#</Text-field>
<Text-field prompt="&gt; " style="Maple Input" layout="Normal"></Text-field>
<Text-field prompt="&gt; " style="Maple Input" layout="Normal">cone_by_cone_approxi_simplex_formulaa:=proc(Simplex,order,xi) local F,W,i,st,d,S,y,P;</Text-field>
<Text-field prompt="&gt; " style="Maple Input" layout="Normal">    F:=0; P:=order; S:=Simplex;</Text-field>
<Text-field prompt="&gt; " style="Maple Input" layout="Normal">    d:=nops(S)-1;</Text-field>
<Text-field prompt="&gt; " style="Maple Input" layout="Normal">    for i from 1 to nops(S) do</Text-field>
<Text-field prompt="&gt; " style="Maple Input" layout="Normal">        W:=[seq(primitive_vector(S[j]-S[i]),j=1..i-1),seq(primitive_vector(S[j]-S[i]),j=i+1..nops(S))];</Text-field>
<Text-field prompt="&gt; " style="Maple Input" layout="Normal">#print(datas,S[i],W,P,xi);</Text-field>
<Text-field prompt="&gt; " style="Maple Input" layout="Normal"></Text-field>
<Text-field prompt="&gt; " style="Maple Input" layout="Normal">        F:=F+approx_Cone_formulaa(S[i],W,P,xi);</Text-field>
<Text-field prompt="&gt; " style="Maple Input" layout="Normal">    od:</Text-field>
<Text-field prompt="&gt; " style="Maple Input" layout="Normal">    F:=eval(subs({TODD=Todd,EXP=exp},F));</Text-field>
<Text-field prompt="&gt; " style="Maple Input" layout="Normal">end:</Text-field>
<Text-field prompt="&gt; " style="Maple Input" layout="Normal">cone_by_cone_approxi_simplex_formulab:=proc(Simplex,order,xi) local F,W,i,st,d,S,y,P;</Text-field>
<Text-field prompt="&gt; " style="Maple Input" layout="Normal">    F:=0; P:=order; S:=Simplex;</Text-field>
<Text-field prompt="&gt; " style="Maple Input" layout="Normal">    d:=nops(S)-1;</Text-field>
<Text-field prompt="&gt; " style="Maple Input" layout="Normal">    for i from 1 to nops(S) do</Text-field>
<Text-field prompt="&gt; " style="Maple Input" layout="Normal">        W:=[seq(primitive_vector(S[j]-S[i]),j=1..i-1),seq(primitive_vector(S[j]-S[i]),j=i+1..nops(S))];</Text-field>
<Text-field prompt="&gt; " style="Maple Input" layout="Normal">        F:=F+approx_Cone_formulab(S[i],W,P,xi);</Text-field>
<Text-field prompt="&gt; " style="Maple Input" layout="Normal">    od:</Text-field>
<Text-field prompt="&gt; " style="Maple Input" layout="Normal">    F:=eval(subs({TODD=Todd,EXP=exp},F));</Text-field>
<Text-field prompt="&gt; " style="Maple Input" layout="Normal">end:</Text-field>
<Text-field prompt="&gt; " style="Maple Input" layout="Normal">cone_by_cone_approxi_simplex_formulab([[0,0],[1,0],[0,1]], 1,xi);</Text-field>
<Text-field prompt="&gt; " style="Maple Input" layout="Normal"></Text-field>
<Text-field prompt="&gt; " style="Maple Input" layout="Normal"># Approximate  functions  S^L  for a  dilated  cone ns+Cone; HERE n is an integer.</Text-field>
<Text-field prompt="&gt; " style="Maple Input" layout="Normal"># Input: n a variable,  s a numeric vector in Q^d,</Text-field>
<Text-field prompt="&gt; " style="Maple Input" layout="Normal"># W a cone, Ispace a subset of [1,2,...d];</Text-field>
<Text-field prompt="&gt; " style="Maple Input" layout="Normal"># xi a list of variables.</Text-field>
<Text-field prompt="&gt; " style="Maple Input" layout="Normal"># Output a function f(n,xi);</Text-field>
<Text-field prompt="&gt; " style="Maple Input" layout="Normal"># This is the function S^{Isplace}(ns+W)(xi), where we emphasize the dependance in n;</Text-field>
<Text-field prompt="&gt; " style="Maple Input" layout="Normal"># We use formulab;</Text-field>
<Text-field prompt="&gt; " style="Maple Input" layout="Normal">#</Text-field>
<Text-field prompt="&gt; " style="Maple Input" layout="Normal"></Text-field>
<Text-field prompt="&gt; " style="Maple Input" layout="Normal"># EXAMPLE ARE GIVEN AFTER THE PROCEDURE:</Text-field>
<Text-field prompt="&gt; " style="Maple Input" layout="Normal"></Text-field>
<Text-field prompt="&gt; " style="Maple Input" layout="Normal">dilatedS_Ispace_Cone:=proc(n,s,W,ISpace,xi) local i,ss,uni_cones,function_on_Cspace,function_on_ISpace,W_projected,WW,WWW,signuni,signL,ts,j,Cspace,out1,out2,s_in_cone_coord,s_Cspace_in_cone_coord,s_small_move,M,newxi,dimL,g,testrank,newP,dilateds,</Text-field>
<Text-field prompt="&gt; " style="Maple Input" layout="Normal">    s_Cspace_in_lattice_coord,news,</Text-field>
<Text-field prompt="&gt; " style="Maple Input" layout="Normal">    ProjLattice;</Text-field>
<Text-field prompt="&gt; " style="Maple Input" layout="Normal"><Font encoding="UTF-8">    #printf(&quot;### dilatedS_Ispace_Cone: W = %a, ISpace = %a\134n&quot;, W, ISpace);</Font></Text-field>
<Text-field prompt="&gt; " style="Maple Input" layout="Normal">    Cspace:=ComplementList(ISpace,nops(W));</Text-field>
<Text-field prompt="&gt; " style="Maple Input" layout="Normal">    ProjLattice := projectedlattice(W,Cspace);</Text-field>
<Text-field prompt="&gt; " style="Maple Input" layout="Normal">    dilateds:=[seq(n*s[i],i=1..nops(W))];</Text-field>
<Text-field prompt="&gt; " style="Maple Input" layout="Normal">    s_Cspace_in_lattice_coord:=projectedvertexinbasislattice(W,Cspace,ProjLattice,s);# I keep n outside;</Text-field>
<Text-field prompt="&gt; " style="Maple Input" layout="Normal">    function_on_ISpace:=functionIb(dilateds,W,ISpace,xi);</Text-field>
<Text-field prompt="&gt; " style="Maple Input" layout="Normal">#from here express in terms of the basis lattice for projected cone.</Text-field>
<Text-field prompt="&gt; " style="Maple Input" layout="Normal">    W_projected:=projectedconeinbasislattice(W,Cspace,ProjLattice):</Text-field>
<Text-field prompt="&gt; " style="Maple Input" layout="Normal">    if W_projected=[] then</Text-field>
<Text-field prompt="&gt; " style="Maple Input" layout="Normal">        out1:=function_on_ISpace[1]/function_on_ISpace[2];</Text-field>
<Text-field prompt="&gt; " style="Maple Input" layout="Normal">    else</Text-field>
<Text-field prompt="&gt; " style="Maple Input" layout="Normal">        newxi:=changeofcoordinates(W,Cspace,ProjLattice,xi);</Text-field>
<Text-field prompt="&gt; " style="Maple Input" layout="Normal">        uni_cones:=cone_dec(W_projected);</Text-field>
<Text-field prompt="&gt; " style="Maple Input" layout="Normal">        out1:=0;</Text-field>
<Text-field prompt="&gt; " style="Maple Input" layout="Normal">        for j from 1 to nops(uni_cones) do</Text-field>
<Text-field prompt="&gt; " style="Maple Input" layout="Normal">            WWW:=uni_cones[j][3];</Text-field>
<Text-field prompt="&gt; " style="Maple Input" layout="Normal">            signuni:=uni_cones[j][1];</Text-field>
<Text-field prompt="&gt; " style="Maple Input" layout="Normal">            ASSERT(abs(uni_cones[j][2])=1, &quot;decomposition not unimodular&quot;);</Text-field>
<Text-field prompt="&gt; " style="Maple Input" layout="Normal">            newP:=MatrixInverse(Transpose(Matrix(WWW)));</Text-field>
<Text-field prompt="&gt; " style="Maple Input" layout="Normal">            news:=convert(Multiply(newP,Vector(s_Cspace_in_lattice_coord)),list); #print(&quot;news&quot;,news);</Text-field>
<Text-field prompt="&gt; " style="Maple Input" layout="Normal"></Text-field>
<Text-field prompt="&gt; " style="Maple Input" layout="Normal">            s_small_move:=[seq(nfractionalpart(N,-numer(news[f]),denom(news[f])),f=1..nops(news))];  #print(&quot;smallmove&quot;,s_small_move);</Text-field>
<Text-field prompt="&gt; " style="Maple Input" layout="Normal">            function_on_Cspace:=functionS(s_small_move,WWW,newxi);</Text-field>
<Text-field prompt="&gt; " style="Maple Input" layout="Normal">            out1:=out1+signuni*function_on_Cspace[1]/function_on_Cspace[2]*function_on_ISpace[1]/function_on_ISpace[2];</Text-field>
<Text-field prompt="&gt; " style="Maple Input" layout="Normal">        od:</Text-field>
<Text-field prompt="&gt; " style="Maple Input" layout="Normal">    fi;</Text-field>
<Text-field prompt="&gt; " style="Maple Input" layout="Normal">    EXP(add(n*s[i]*xi[i],i=1..nops(W)))*out1;</Text-field>
<Text-field prompt="&gt; " style="Maple Input" layout="Normal">end:</Text-field>
<Text-field prompt="&gt; " style="Maple Input" layout="Normal"></Text-field>
<Text-field prompt="&gt; " style="Maple Input" layout="Normal"></Text-field>
<Text-field prompt="&gt; " style="Maple Input" layout="Normal"></Text-field>
<Text-field prompt="&gt; " style="Maple Input" layout="Normal"></Text-field>
<Text-field prompt="&gt; " style="Maple Input" layout="Normal"></Text-field>
<Text-field prompt="&gt; " style="Maple Input" layout="Normal"></Text-field>
<Text-field prompt="&gt; " style="Maple Input" layout="Normal">#ApproxEhrhartSimplexgeneric(n,[[0,0],[1/2,0],[0,1/2]], 1,xi);</Text-field>
<Text-field prompt="&gt; " style="Maple Input" layout="Normal">random_vector:=proc(N,d) local R;</Text-field>
<Text-field prompt="&gt; " style="Maple Input" layout="Normal">    R:=rand(N);</Text-field>
<Text-field prompt="&gt; " style="Maple Input" layout="Normal">    [seq(R()+1,i=1..d)]:</Text-field>
<Text-field prompt="&gt; " style="Maple Input" layout="Normal">end:</Text-field>
<Text-field prompt="&gt; " style="Maple Input" layout="Normal"></Text-field>
<Text-field prompt="&gt; " style="Maple Input" layout="Normal"></Text-field>
<Text-field prompt="&gt; " style="Maple Input" layout="Normal"></Text-field>
<Text-field prompt="&gt; " style="Maple Input" layout="Normal"></Text-field>
<Text-field prompt="&gt; " style="Maple Input" layout="Normal">#### LATTE INTERFACE FUNCTION:</Text-field>
<Text-field prompt="&gt; " style="Maple Input" layout="Normal">##Used by latte to find just the top k coefficients of the ehrhart polynomial.</Text-field>
<Text-field prompt="&gt; " style="Maple Input" layout="Normal">##Because we do this by finding the polynomial per linear form, we do not print</Text-field>
<Text-field prompt="&gt; " style="Maple Input" layout="Normal">##  out the coefficients incrementally, and hence do not have to store </Text-field>
<Text-field prompt="&gt; " style="Maple Input" layout="Normal">##  partial results which gives this function a smaller memory footprint than </Text-field>
<Text-field prompt="&gt; " style="Maple Input" layout="Normal">##  the printIncrementalEhrhartPolynomial function.</Text-field>
<Text-field prompt="&gt; " style="Maple Input" layout="Normal">##But this function could find the entire ehrhart polynomial if asked to.</Text-field>
<Text-field prompt="&gt; " style="Maple Input" layout="Normal">#input</Text-field>
<Text-field prompt="&gt; " style="Maple Input" layout="Normal">#	n: symbolic variable. the coefficients are functions of n. example: 3mod(n,2)^3</Text-field>
<Text-field prompt="&gt; " style="Maple Input" layout="Normal">#	nn: symbolic variable. The coefficients are graded by nn. example (3mod(n,2)^3 + 2)*nn^3</Text-field>
<Text-field prompt="&gt; " style="Maple Input" layout="Normal">#	simpleCones: the polytope.</Text-field>
<Text-field prompt="&gt; " style="Maple Input" layout="Normal">#	linearForms: list of powers of linear forms</Text-field>
<Text-field prompt="&gt; " style="Maple Input" layout="Normal">#	d: dimension of the polytope</Text-field>
<Text-field prompt="&gt; " style="Maple Input" layout="Normal">#	useRealDilations: ture=the polynomial can be evaluaded at rational dilations.</Text-field>
<Text-field prompt="&gt; " style="Maple Input" layout="Normal">#	topK: find the top topK coefficients (not the topK +1) or all of them if topk=-1</Text-field>
<Text-field prompt="&gt; " style="Maple Input" layout="Normal">#	filename: if -1, the polynomial is not saved to a file. Else, the polynomial is saved to fileName.</Text-field>
<Text-field prompt="&gt; " style="Maple Input" layout="Normal">findEhrhartPolynomial:=proc(n,nn,simpleCones,linearForms, d,useRealDilations, topK, fileName) </Text-field>
<Text-field prompt="&gt; " style="Maple Input" layout="Normal">	local coef, M, ell, ehrhartPoly, mapleLinForm;</Text-field>
<Text-field prompt="&gt; " style="Maple Input" layout="Normal">	local fPtr;</Text-field>
<Text-field prompt="&gt; " style="Maple Input" layout="Normal">	</Text-field>
<Text-field prompt="&gt; " style="Maple Input" layout="Normal"></Text-field>
<Text-field prompt="&gt; " style="Maple Input" layout="Normal">	ASSERT(topK &gt; 0 or topK = -1);</Text-field>
<Text-field prompt="&gt; " style="Maple Input" layout="Normal">	</Text-field>
<Text-field prompt="&gt; " style="Maple Input" layout="Normal">	ehrhartPoly:=0;</Text-field>
<Text-field prompt="&gt; " style="Maple Input" layout="Normal">	</Text-field>
<Text-field prompt="&gt; " style="Maple Input" layout="Normal">	#loop over every linear form and collect the polynomial.</Text-field>
<Text-field prompt="&gt; " style="Maple Input" layout="Normal">	for mapleLinForm in linearForms do</Text-field>
<Text-field prompt="&gt; " style="Maple Input" layout="Normal">		coef:=mapleLinForm[1];</Text-field>
<Text-field prompt="&gt; " style="Maple Input" layout="Normal">		M   :=mapleLinForm[2][1];</Text-field>
<Text-field prompt="&gt; " style="Maple Input" layout="Normal">		ell :=mapleLinForm[2][2];</Text-field>
<Text-field prompt="&gt; " style="Maple Input" layout="Normal"></Text-field>
<Text-field prompt="&gt; " style="Maple Input" layout="Normal">		if (topK &gt; 0) then</Text-field>
<Text-field prompt="&gt; " style="Maple Input" layout="Normal">			ehrhartPoly:= ehrhartPoly + coef*findEhrhartPolynomial_linearForm(n,nn,simpleCones,ell,M,d,useRealDilations, topK-1);</Text-field>
<Text-field prompt="&gt; " style="Maple Input" layout="Normal">		else</Text-field>
<Text-field prompt="&gt; " style="Maple Input" layout="Normal">			ehrhartPoly:= ehrhartPoly + coef*findEhrhartPolynomial_linearForm(n,nn,simpleCones,ell,M,d,useRealDilations, M+d);</Text-field>
<Text-field prompt="&gt; " style="Maple Input" layout="Normal">		fi;</Text-field>
<Text-field prompt="&gt; " style="Maple Input" layout="Normal">	end;</Text-field>
<Text-field prompt="&gt; " style="Maple Input" layout="Normal">	</Text-field>
<Text-field prompt="&gt; " style="Maple Input" layout="Normal">	if fileName &lt;&gt; -1 then</Text-field>
<Text-field prompt="&gt; " style="Maple Input" layout="Normal">		fPtr:=fopen(fileName, WRITE, TEXT);</Text-field>
<Text-field prompt="&gt; " style="Maple Input" layout="Normal"><Font encoding="UTF-8">    	fprintf(fPtr, &quot;epoly:= %a;\134\134n&quot;, ehrhartPoly);</Font></Text-field>
<Text-field prompt="&gt; " style="Maple Input" layout="Normal"><Font encoding="UTF-8">		fprintf(fPtr, &quot;\134n&quot;);</Font></Text-field>
<Text-field prompt="&gt; " style="Maple Input" layout="Normal">    	fclose(fPtr);</Text-field>
<Text-field prompt="&gt; " style="Maple Input" layout="Normal">	fi;</Text-field>
<Text-field prompt="&gt; " style="Maple Input" layout="Normal">	</Text-field>
<Text-field prompt="&gt; " style="Maple Input" layout="Normal">	return ehrhartPoly;</Text-field>
<Text-field prompt="&gt; " style="Maple Input" layout="Normal">end:</Text-field>
<Text-field prompt="&gt; " style="Maple Input" layout="Normal"></Text-field>
<Text-field prompt="&gt; " style="Maple Input" layout="Normal"></Text-field>
<Text-field prompt="&gt; " style="Maple Input" layout="Normal"></Text-field>
<Text-field prompt="&gt; " style="Maple Input" layout="Normal">#Computes the top weighted ehrhart polynomial's coefficients with one power of a linear form weight</Text-field>
<Text-field prompt="&gt; " style="Maple Input" layout="Normal">#input</Text-field>
<Text-field prompt="&gt; " style="Maple Input" layout="Normal">#	ell: the linear form</Text-field>
<Text-field prompt="&gt; " style="Maple Input" layout="Normal">#	M: the power of the linear form</Text-field>
<Text-field prompt="&gt; " style="Maple Input" layout="Normal">#	d: dimension of the polytope</Text-field>
<Text-field prompt="&gt; " style="Maple Input" layout="Normal">#	simpleCones: the polytope.</Text-field>
<Text-field prompt="&gt; " style="Maple Input" layout="Normal">#	n: symbolic variable. the coefficients are functions of n. example: 3mod(n,2)^3</Text-field>
<Text-field prompt="&gt; " style="Maple Input" layout="Normal">#	nn: symbolic variable. The coefficients are graded by N. example (3mod(n,2)^3 + 2)*nn^3</Text-field>
<Text-field prompt="&gt; " style="Maple Input" layout="Normal">#	topK: compute the top topK+1 coefficients.</Text-field>
<Text-field prompt="&gt; " style="Maple Input" layout="Normal">#return: the polynomial</Text-field>
<Text-field prompt="&gt; " style="Maple Input" layout="Normal">findEhrhartPolynomial_linearForm:=proc(n,nn,simpleCones,ell,M,d, useRealDilations, topK) </Text-field>
<Text-field prompt="&gt; " style="Maple Input" layout="Normal"> local order, newOrder, xi;</Text-field>
<Text-field prompt="&gt; " style="Maple Input" layout="Normal"> local partialF, partialSeries; </Text-field>
<Text-field prompt="&gt; " style="Maple Input" layout="Normal"> local totalSeries, term;</Text-field>
<Text-field prompt="&gt; " style="Maple Input" layout="Normal"> local l, j, i, a, s, W, C, K,KK, reg, output;</Text-field>
<Text-field prompt="&gt; " style="Maple Input" layout="Normal"> local cone, rays;</Text-field>
<Text-field prompt="&gt; " style="Maple Input" layout="Normal"> local ehrhartPoly;</Text-field>
<Text-field prompt="&gt; " style="Maple Input" layout="Normal"> local new_n;</Text-field>
<Text-field prompt="&gt; " style="Maple Input" layout="Normal"> </Text-field>
<Text-field prompt="&gt; " style="Maple Input" layout="Normal">  	new_n := `tools/gensym`('myn');</Text-field>
<Text-field prompt="&gt; " style="Maple Input" layout="Normal">  	</Text-field>
<Text-field prompt="&gt; " style="Maple Input" layout="Normal"> 	ehrhartPoly:=0;    </Text-field>
<Text-field prompt="&gt; " style="Maple Input" layout="Normal">    order:=min(M+d, topK);</Text-field>
<Text-field prompt="&gt; " style="Maple Input" layout="Normal">    #order:=M+d;</Text-field>
<Text-field prompt="&gt; " style="Maple Input" layout="Normal">    </Text-field>
<Text-field prompt="&gt; " style="Maple Input" layout="Normal">    reg:=random_vector(5000,d);</Text-field>
<Text-field prompt="&gt; " style="Maple Input" layout="Normal">    xi:=[seq(t*(ell[i]+epsilon*reg[i]),i=1..d)];</Text-field>
<Text-field prompt="&gt; " style="Maple Input" layout="Normal">          </Text-field>
<Text-field prompt="&gt; " style="Maple Input" layout="Normal">	partialF:=Array([seq(0,ll=0..order+1)]);</Text-field>
<Text-field prompt="&gt; " style="Maple Input" layout="Normal">	partialSeries:=Array([seq(0,ll=0..order+1)]);	</Text-field>
<Text-field prompt="&gt; " style="Maple Input" layout="Normal">    </Text-field>
<Text-field prompt="&gt; " style="Maple Input" layout="Normal">    for j from 0 to order do</Text-field>
<Text-field prompt="&gt; " style="Maple Input" layout="Normal">    	C:=choose(d,j);</Text-field>
<Text-field prompt="&gt; " style="Maple Input" layout="Normal">    	output:=0;</Text-field>
<Text-field prompt="&gt; " style="Maple Input" layout="Normal">    	#cc[j]:=(-1)^(order-j)*binomial(d-j-1,d-order-1);</Text-field>
<Text-field prompt="&gt; " style="Maple Input" layout="Normal">    	</Text-field>
<Text-field prompt="&gt; " style="Maple Input" layout="Normal">    	#compute the valuation over each cone.</Text-field>
<Text-field prompt="&gt; " style="Maple Input" layout="Normal">    	for cone in simpleCones do</Text-field>
<Text-field prompt="&gt; " style="Maple Input" layout="Normal"></Text-field>
<Text-field prompt="&gt; " style="Maple Input" layout="Normal">    		s:=cone[1]; #vertex</Text-field>
<Text-field prompt="&gt; " style="Maple Input" layout="Normal">    		W:=[seq(primitive_vector(cone[2][j]), j=1..d)]; #rays of the cone.</Text-field>
<Text-field prompt="&gt; " style="Maple Input" layout="Normal">	    	for a from 1 to nops(C) do</Text-field>
<Text-field prompt="&gt; " style="Maple Input" layout="Normal">        		K:=C[a]; KK:=ComplementList(K,nops(W));</Text-field>
<Text-field prompt="&gt; " style="Maple Input" layout="Normal">        		</Text-field>
<Text-field prompt="&gt; " style="Maple Input" layout="Normal">        		#put the loop here: loop over every ell/xi</Text-field>
<Text-field prompt="&gt; " style="Maple Input" layout="Normal">        		if useRealDilations then</Text-field>
<Text-field prompt="&gt; " style="Maple Input" layout="Normal">        			output:=output + dilatedS_Ispace_Cone_real(new_n,s,W,KK,xi) ;</Text-field>
<Text-field prompt="&gt; " style="Maple Input" layout="Normal">        		else</Text-field>
<Text-field prompt="&gt; " style="Maple Input" layout="Normal">        			output:=output + dilatedS_Ispace_Cone(new_n,s,W,KK,xi) ;</Text-field>
<Text-field prompt="&gt; " style="Maple Input" layout="Normal">        		fi;</Text-field>
<Text-field prompt="&gt; " style="Maple Input" layout="Normal"></Text-field>
<Text-field prompt="&gt; " style="Maple Input" layout="Normal">        	od;</Text-field>
<Text-field prompt="&gt; " style="Maple Input" layout="Normal">        od;</Text-field>
<Text-field prompt="&gt; " style="Maple Input" layout="Normal">        partialF[j+1]:=eval(subs({TODD=Todd,EXP=exp},output));</Text-field>
<Text-field prompt="&gt; " style="Maple Input" layout="Normal">        </Text-field>
<Text-field prompt="&gt; " style="Maple Input" layout="Normal">        partialSeries[j+1]:=coeff(series(partialF[j+1],t=0,M+d+2),t,M);</Text-field>
<Text-field prompt="&gt; " style="Maple Input" layout="Normal">        partialSeries[j+1]:=coeff(series(partialSeries[j+1],epsilon=0,d+2),epsilon,0);</Text-field>
<Text-field prompt="&gt; " style="Maple Input" layout="Normal">    </Text-field>
<Text-field prompt="&gt; " style="Maple Input" layout="Normal">        totalSeries:=0;</Text-field>
<Text-field prompt="&gt; " style="Maple Input" layout="Normal">        for l from 0 to j do</Text-field>
<Text-field prompt="&gt; " style="Maple Input" layout="Normal">    		newOrder:=j;</Text-field>
<Text-field prompt="&gt; " style="Maple Input" layout="Normal">    		totalSeries:=totalSeries + (-1)^(newOrder-l)*binomial(d-l-1,d-newOrder-1)*partialSeries[l+1];</Text-field>
<Text-field prompt="&gt; " style="Maple Input" layout="Normal">    	od; #for l</Text-field>
<Text-field prompt="&gt; " style="Maple Input" layout="Normal">    	totalSeries:=coeff(totalSeries,new_n,M+d-j);</Text-field>
<Text-field prompt="&gt; " style="Maple Input" layout="Normal">    	</Text-field>
<Text-field prompt="&gt; " style="Maple Input" layout="Normal">    	#we need to mult. by M! because we are computing w/the weight 1/M!* ell^M</Text-field>
<Text-field prompt="&gt; " style="Maple Input" layout="Normal">    	term:= subs({new_n=n, N=n},totalSeries)*factorial(M);</Text-field>
<Text-field prompt="&gt; " style="Maple Input" layout="Normal">    	ehrhartPoly:=ehrhartPoly+term*nn^(M+d-j);    	</Text-field>
<Text-field prompt="&gt; " style="Maple Input" layout="Normal">    od;</Text-field>
<Text-field prompt="&gt; " style="Maple Input" layout="Normal"></Text-field>
<Text-field prompt="&gt; " style="Maple Input" layout="Normal">    return ehrhartPoly;</Text-field>
<Text-field prompt="&gt; " style="Maple Input" layout="Normal">end:</Text-field>
<Text-field prompt="&gt; " style="Maple Input" layout="Normal"></Text-field>
<Text-field prompt="&gt; " style="Maple Input" layout="Normal"></Text-field>
<Text-field prompt="&gt; " style="Maple Input" layout="Normal">#### LATTE INTERFACE FUNCTION:</Text-field>
<Text-field prompt="&gt; " style="Maple Input" layout="Normal">##Used by latte to print ALL of the coefficients of the ehrhart polynomial coefficients incrementally</Text-field>
<Text-field prompt="&gt; " style="Maple Input" layout="Normal">##But this function could compute just the top k ehrhart polynomial incrementally.</Text-field>
<Text-field prompt="&gt; " style="Maple Input" layout="Normal">##If the user wants the top k, latte calls the function findEhrhartPolynomial</Text-field>
<Text-field prompt="&gt; " style="Maple Input" layout="Normal">##  instead because it computes the polynomial per linear form, and hence has a small </Text-field>
<Text-field prompt="&gt; " style="Maple Input" layout="Normal">##  memory footprint because printIncrementalEhrhartPolynomial finds the </Text-field>
<Text-field prompt="&gt; " style="Maple Input" layout="Normal">##  current coefficient of all the linear forms at once.</Text-field>
<Text-field prompt="&gt; " style="Maple Input" layout="Normal"></Text-field>
<Text-field prompt="&gt; " style="Maple Input" layout="Normal">#input</Text-field>
<Text-field prompt="&gt; " style="Maple Input" layout="Normal">#	n: symbolic variable. the coefficients are functions of n. example: 3mod(n,2)^3</Text-field>
<Text-field prompt="&gt; " style="Maple Input" layout="Normal">#	nn: symbolic variable. The coefficients are graded by N. example (3mod(n,2)^3 + 2)*nn^3</Text-field>
<Text-field prompt="&gt; " style="Maple Input" layout="Normal">#	simpleCones: the polytope.</Text-field>
<Text-field prompt="&gt; " style="Maple Input" layout="Normal">#	linearForms: list of powers of linear forms</Text-field>
<Text-field prompt="&gt; " style="Maple Input" layout="Normal">#	d: dimension of the polytope</Text-field>
<Text-field prompt="&gt; " style="Maple Input" layout="Normal">#	useRealDilations: ture=the polynomial can be evaluaded at rational dilations.</Text-field>
<Text-field prompt="&gt; " style="Maple Input" layout="Normal">#	topK: find the top topK coefficients (note this function does not compute the top topk+1)</Text-field>
<Text-field prompt="&gt; " style="Maple Input" layout="Normal">#	filename: if -1, the polynomial is not saved to a file. Else, the polynomial is saved to fileName.</Text-field>
<Text-field prompt="&gt; " style="Maple Input" layout="Normal">printIncrementalEhrhartPolynomial:=proc(n,nn,simpleCones,linearForms, d, useRealDilations, topK, fileName) </Text-field>
<Text-field prompt="&gt; " style="Maple Input" layout="Normal"> local xi, numLinearForms, M, iLF, ell, minDegree, currentDegree, coef_current, M_current, currentDifference;</Text-field>
<Text-field prompt="&gt; " style="Maple Input" layout="Normal"> local partialF, partialSeries, totalCoeffSum; </Text-field>
<Text-field prompt="&gt; " style="Maple Input" layout="Normal"> local term;</Text-field>
<Text-field prompt="&gt; " style="Maple Input" layout="Normal"> local l, j, i, a, s, W, C, K, KK, reg, output;</Text-field>
<Text-field prompt="&gt; " style="Maple Input" layout="Normal"> local cone, rays;</Text-field>
<Text-field prompt="&gt; " style="Maple Input" layout="Normal"> local ehrhartPoly;</Text-field>
<Text-field prompt="&gt; " style="Maple Input" layout="Normal"> local fPtr; #file pointer.</Text-field>
<Text-field prompt="&gt; " style="Maple Input" layout="Normal"> local new_n;</Text-field>
<Text-field prompt="&gt; " style="Maple Input" layout="Normal"> </Text-field>
<Text-field prompt="&gt; " style="Maple Input" layout="Normal"> 	new_n := `tools/gensym`('myn');</Text-field>
<Text-field prompt="&gt; " style="Maple Input" layout="Normal"> 	</Text-field>
<Text-field prompt="&gt; " style="Maple Input" layout="Normal"> 	#notes to self. iLF is &quot;Index of Linear Form&quot;</Text-field>
<Text-field prompt="&gt; " style="Maple Input" layout="Normal">    #coef:=linearForms[iLF][1];</Text-field>
<Text-field prompt="&gt; " style="Maple Input" layout="Normal">	#M   :=linearForms[iLF][2][1];</Text-field>
<Text-field prompt="&gt; " style="Maple Input" layout="Normal">	#ell :=linearForms[iLF][2][2];</Text-field>
<Text-field prompt="&gt; " style="Maple Input" layout="Normal">	</Text-field>
<Text-field prompt="&gt; " style="Maple Input" layout="Normal">	#set up the integrand/residue direction.    </Text-field>
<Text-field prompt="&gt; " style="Maple Input" layout="Normal">    numLinearForms:=nops(linearForms);</Text-field>
<Text-field prompt="&gt; " style="Maple Input" layout="Normal">    M:=linearForms[1][2][1];</Text-field>
<Text-field prompt="&gt; " style="Maple Input" layout="Normal">    xi:=Array(1..numLinearForms);</Text-field>
<Text-field prompt="&gt; " style="Maple Input" layout="Normal">    for iLF from 1 to numLinearForms do</Text-field>
<Text-field prompt="&gt; " style="Maple Input" layout="Normal">    	#construct a different residue direction for each linear form.</Text-field>
<Text-field prompt="&gt; " style="Maple Input" layout="Normal">    	</Text-field>
<Text-field prompt="&gt; " style="Maple Input" layout="Normal">    	reg:=random_vector(5000,d);</Text-field>
<Text-field prompt="&gt; " style="Maple Input" layout="Normal">    	ell :=linearForms[iLF][2][2];</Text-field>
<Text-field prompt="&gt; " style="Maple Input" layout="Normal">    	xi[iLF]:=[seq(t*(ell[i]+epsilon*reg[i]),i=1..d)];    	</Text-field>
<Text-field prompt="&gt; " style="Maple Input" layout="Normal">    	</Text-field>
<Text-field prompt="&gt; " style="Maple Input" layout="Normal">    	#find the largest degree of all the linear forms.</Text-field>
<Text-field prompt="&gt; " style="Maple Input" layout="Normal">    	M:=max(M, linearForms[iLF][2][1]);</Text-field>
<Text-field prompt="&gt; " style="Maple Input" layout="Normal">    od;</Text-field>
<Text-field prompt="&gt; " style="Maple Input" layout="Normal"></Text-field>
<Text-field prompt="&gt; " style="Maple Input" layout="Normal">    #set up the output file if needed</Text-field>
<Text-field prompt="&gt; " style="Maple Input" layout="Normal">    if fileName &lt;&gt; -1 then</Text-field>
<Text-field prompt="&gt; " style="Maple Input" layout="Normal">    	fPtr:=fopen(fileName, WRITE, TEXT);</Text-field>
<Text-field prompt="&gt; " style="Maple Input" layout="Normal">    	fprintf(fPtr, &quot;epoly:= &quot;);</Text-field>
<Text-field prompt="&gt; " style="Maple Input" layout="Normal">    fi;</Text-field>
<Text-field prompt="&gt; " style="Maple Input" layout="Normal">    </Text-field>
<Text-field prompt="&gt; " style="Maple Input" layout="Normal">    ehrhartPoly:=0;</Text-field>
<Text-field prompt="&gt; " style="Maple Input" layout="Normal"></Text-field>
<Text-field prompt="&gt; " style="Maple Input" layout="Normal">    #topK should be a natural number or -1.</Text-field>
<Text-field prompt="&gt; " style="Maple Input" layout="Normal">    ASSERT(topK = -1 or topK &gt; 0);</Text-field>
<Text-field prompt="&gt; " style="Maple Input" layout="Normal">    </Text-field>
<Text-field prompt="&gt; " style="Maple Input" layout="Normal"> 	if topK &gt; 0 then </Text-field>
<Text-field prompt="&gt; " style="Maple Input" layout="Normal">    	minDegree:=M+d-(topK-1);</Text-field>
<Text-field prompt="&gt; " style="Maple Input" layout="Normal">    else</Text-field>
<Text-field prompt="&gt; " style="Maple Input" layout="Normal">    	minDegree:=0;</Text-field>
<Text-field prompt="&gt; " style="Maple Input" layout="Normal">    fi;</Text-field>
<Text-field prompt="&gt; " style="Maple Input" layout="Normal">    </Text-field>
<Text-field prompt="&gt; " style="Maple Input" layout="Normal">    #these are just placeholders for the dilatedS_Ispace_Cone_real() output.</Text-field>
<Text-field prompt="&gt; " style="Maple Input" layout="Normal">	partialF:=0; </Text-field>
<Text-field prompt="&gt; " style="Maple Input" layout="Normal">	partialSeries:=Array(1..numLinearForms, 1..(M+d+1), 0); </Text-field>
<Text-field prompt="&gt; " style="Maple Input" layout="Normal">	#holds the partial taylor series of the rational functions.</Text-field>
<Text-field prompt="&gt; " style="Maple Input" layout="Normal">		#Note: The index of array's start at ONE in maple.</Text-field>
<Text-field prompt="&gt; " style="Maple Input" layout="Normal">		#the rows corresponds to the linear forms. Columns corresponds to the  difference between the current power and the current degree</Text-field>
<Text-field prompt="&gt; " style="Maple Input" layout="Normal">		#example: partialSeries[1][2+1] is the rational functions when we are summing over choose(d,2)</Text-field>
<Text-field prompt="&gt; " style="Maple Input" layout="Normal"></Text-field>
<Text-field prompt="&gt; " style="Maple Input" layout="Normal">		</Text-field>
<Text-field prompt="&gt; " style="Maple Input" layout="Normal">    </Text-field>
<Text-field prompt="&gt; " style="Maple Input" layout="Normal">	</Text-field>
<Text-field prompt="&gt; " style="Maple Input" layout="Normal">	#for every degree of the ehrhart polynomial we are going to compute</Text-field>
<Text-field prompt="&gt; " style="Maple Input" layout="Normal">	for currentDegree from M+d to minDegree by -1 do</Text-field>
<Text-field prompt="&gt; " style="Maple Input" layout="Normal">	</Text-field>
<Text-field prompt="&gt; " style="Maple Input" layout="Normal">		#for every linear form.</Text-field>
<Text-field prompt="&gt; " style="Maple Input" layout="Normal">		for iLF from 1 to numLinearForms do</Text-field>
<Text-field prompt="&gt; " style="Maple Input" layout="Normal">		    coef_current:=linearForms[iLF][1];</Text-field>
<Text-field prompt="&gt; " style="Maple Input" layout="Normal">		    M_current   :=linearForms[iLF][2][1];</Text-field>
<Text-field prompt="&gt; " style="Maple Input" layout="Normal">		    </Text-field>
<Text-field prompt="&gt; " style="Maple Input" layout="Normal">			#does this linear form add a coefficient of currentDegree to the polynomial?</Text-field>
<Text-field prompt="&gt; " style="Maple Input" layout="Normal">			if currentDegree &gt; M_current + d then</Text-field>
<Text-field prompt="&gt; " style="Maple Input" layout="Normal">				next; #skip this linear form.</Text-field>
<Text-field prompt="&gt; " style="Maple Input" layout="Normal">			fi;</Text-field>
<Text-field prompt="&gt; " style="Maple Input" layout="Normal">		</Text-field>
<Text-field prompt="&gt; " style="Maple Input" layout="Normal">			#figure out how far the currentDegree is from M_current + d</Text-field>
<Text-field prompt="&gt; " style="Maple Input" layout="Normal">			currentDifference:=M_current + d - currentDegree; </Text-field>
<Text-field prompt="&gt; " style="Maple Input" layout="Normal">			</Text-field>
<Text-field prompt="&gt; " style="Maple Input" layout="Normal">			C:=choose(d, currentDifference);</Text-field>
<Text-field prompt="&gt; " style="Maple Input" layout="Normal">			</Text-field>
<Text-field prompt="&gt; " style="Maple Input" layout="Normal">			output:=0; #output is the &quot;short rational&quot; functions for this order</Text-field>
<Text-field prompt="&gt; " style="Maple Input" layout="Normal">			</Text-field>
<Text-field prompt="&gt; " style="Maple Input" layout="Normal">			</Text-field>
<Text-field prompt="&gt; " style="Maple Input" layout="Normal">			#compute the integrand/valuation over each cone</Text-field>
<Text-field prompt="&gt; " style="Maple Input" layout="Normal">			for cone in simpleCones do</Text-field>
<Text-field prompt="&gt; " style="Maple Input" layout="Normal">			</Text-field>
<Text-field prompt="&gt; " style="Maple Input" layout="Normal">    			s:=cone[1]; #vertex</Text-field>
<Text-field prompt="&gt; " style="Maple Input" layout="Normal">    			W:=[seq(primitive_vector(cone[2][j]), j=1..d)]; #rays of the cone.</Text-field>
<Text-field prompt="&gt; " style="Maple Input" layout="Normal">    			for a from 1 to nops(C) do</Text-field>
<Text-field prompt="&gt; " style="Maple Input" layout="Normal">        			K:=C[a]; </Text-field>
<Text-field prompt="&gt; " style="Maple Input" layout="Normal">        			KK:=ComplementList(K,nops(W));</Text-field>
<Text-field prompt="&gt; " style="Maple Input" layout="Normal">        		</Text-field>
<Text-field prompt="&gt; " style="Maple Input" layout="Normal">        			</Text-field>
<Text-field prompt="&gt; " style="Maple Input" layout="Normal">        			if useRealDilations then</Text-field>
<Text-field prompt="&gt; " style="Maple Input" layout="Normal">        				output:=output + coef_current*factorial(M_current)*dilatedS_Ispace_Cone_real(new_n,s,W,KK,xi[iLF]) ;</Text-field>
<Text-field prompt="&gt; " style="Maple Input" layout="Normal">        			else</Text-field>
<Text-field prompt="&gt; " style="Maple Input" layout="Normal">        				output:=output + coef_current*factorial(M_current)*dilatedS_Ispace_Cone(new_n,s,W,KK,xi[iLF]) ;</Text-field>
<Text-field prompt="&gt; " style="Maple Input" layout="Normal">        			fi;</Text-field>
<Text-field prompt="&gt; " style="Maple Input" layout="Normal">        		</Text-field>
<Text-field prompt="&gt; " style="Maple Input" layout="Normal">        		od; </Text-field>
<Text-field prompt="&gt; " style="Maple Input" layout="Normal">			od; #for every simple cone</Text-field>
<Text-field prompt="&gt; " style="Maple Input" layout="Normal">			</Text-field>
<Text-field prompt="&gt; " style="Maple Input" layout="Normal">			#partialF is now the sum of rational functions for every cone and the current linear form.</Text-field>
<Text-field prompt="&gt; " style="Maple Input" layout="Normal">			partialF:=eval(subs({TODD=Todd,EXP=exp},output));</Text-field>
<Text-field prompt="&gt; " style="Maple Input" layout="Normal">			</Text-field>
<Text-field prompt="&gt; " style="Maple Input" layout="Normal">			#find the series expansion of partialF.        </Text-field>
<Text-field prompt="&gt; " style="Maple Input" layout="Normal">			partialSeries[iLF, currentDifference+1]:=coeff(series(partialF,t=0,M_current+d+2),t,M_current);			</Text-field>
<Text-field prompt="&gt; " style="Maple Input" layout="Normal">			partialSeries[iLF, currentDifference+1]:=coeff(series(partialSeries[iLF, currentDifference+1],epsilon=0,d+2),epsilon,0);</Text-field>
<Text-field prompt="&gt; " style="Maple Input" layout="Normal"></Text-field>
<Text-field prompt="&gt; " style="Maple Input" layout="Normal">			</Text-field>
<Text-field prompt="&gt; " style="Maple Input" layout="Normal">        od; #for every linear form</Text-field>
<Text-field prompt="&gt; " style="Maple Input" layout="Normal">        </Text-field>
<Text-field prompt="&gt; " style="Maple Input" layout="Normal">        #we are ready to find the coefficient of currentDegree</Text-field>
<Text-field prompt="&gt; " style="Maple Input" layout="Normal">        </Text-field>
<Text-field prompt="&gt; " style="Maple Input" layout="Normal">        totalCoeffSum:=0;</Text-field>
<Text-field prompt="&gt; " style="Maple Input" layout="Normal">		for iLF from 1 to numLinearForms do</Text-field>
<Text-field prompt="&gt; " style="Maple Input" layout="Normal">		    M_current   :=linearForms[iLF][2][1];</Text-field>
<Text-field prompt="&gt; " style="Maple Input" layout="Normal">		    </Text-field>
<Text-field prompt="&gt; " style="Maple Input" layout="Normal">			#does this linear form add a coefficient of currentDegree to the polynomial?</Text-field>
<Text-field prompt="&gt; " style="Maple Input" layout="Normal">			if currentDegree &gt; M_current + d then</Text-field>
<Text-field prompt="&gt; " style="Maple Input" layout="Normal">				next; #skip this linear form.</Text-field>
<Text-field prompt="&gt; " style="Maple Input" layout="Normal">			fi;</Text-field>
<Text-field prompt="&gt; " style="Maple Input" layout="Normal">			</Text-field>
<Text-field prompt="&gt; " style="Maple Input" layout="Normal">			#figure out how far the currentDegree is from M_current + d</Text-field>
<Text-field prompt="&gt; " style="Maple Input" layout="Normal">			currentDifference:=M_current + d - currentDegree; </Text-field>
<Text-field prompt="&gt; " style="Maple Input" layout="Normal">		</Text-field>
<Text-field prompt="&gt; " style="Maple Input" layout="Normal">			for l from 0 to currentDifference do</Text-field>
<Text-field prompt="&gt; " style="Maple Input" layout="Normal">				</Text-field>
<Text-field prompt="&gt; " style="Maple Input" layout="Normal">	    		totalCoeffSum:=totalCoeffSum + (-1)^(currentDifference-l)*binomial(d-l-1,d-currentDifference-1)*coeff(partialSeries[iLF, l+1], new_n, currentDegree);</Text-field>
<Text-field prompt="&gt; " style="Maple Input" layout="Normal">    		od; #for l</Text-field>
<Text-field prompt="&gt; " style="Maple Input" layout="Normal">    	</Text-field>
<Text-field prompt="&gt; " style="Maple Input" layout="Normal">		od; #for every linear form.</Text-field>
<Text-field prompt="&gt; " style="Maple Input" layout="Normal">        term:= subs({new_n=n},totalCoeffSum);</Text-field>
<Text-field prompt="&gt; " style="Maple Input" layout="Normal">    	term:= subs({N=n},totalCoeffSum);</Text-field>
<Text-field prompt="&gt; " style="Maple Input" layout="Normal">    	ehrhartPoly:=ehrhartPoly+term*nn^(currentDegree);</Text-field>
<Text-field prompt="&gt; " style="Maple Input" layout="Normal"><Font encoding="UTF-8">    	printf(&quot;+ %a\134n&quot;, term*nn^(currentDegree));</Font></Text-field>
<Text-field prompt="&gt; " style="Maple Input" layout="Normal"></Text-field>
<Text-field prompt="&gt; " style="Maple Input" layout="Normal">    	#also print to output file if needed</Text-field>
<Text-field prompt="&gt; " style="Maple Input" layout="Normal">    	if fileName &lt;&gt; -1 then</Text-field>
<Text-field prompt="&gt; " style="Maple Input" layout="Normal"><Font encoding="UTF-8">    		fprintf(fPtr, &quot;\134\134 \134n+ %a&quot;, term*nn^(currentDegree));</Font></Text-field>
<Text-field prompt="&gt; " style="Maple Input" layout="Normal">    	fi;</Text-field>
<Text-field prompt="&gt; " style="Maple Input" layout="Normal">	od; #for every degree of the polynomial.</Text-field>
<Text-field prompt="&gt; " style="Maple Input" layout="Normal">	</Text-field>
<Text-field prompt="&gt; " style="Maple Input" layout="Normal">	</Text-field>
<Text-field prompt="&gt; " style="Maple Input" layout="Normal">   	#close the file if needed.</Text-field>
<Text-field prompt="&gt; " style="Maple Input" layout="Normal">  	if fileName &lt;&gt; -1 then</Text-field>
<Text-field prompt="&gt; " style="Maple Input" layout="Normal"><Font encoding="UTF-8">  		fprintf(fPtr, &quot;;\134n&quot;);</Font></Text-field>
<Text-field prompt="&gt; " style="Maple Input" layout="Normal">    	fclose(fPtr);</Text-field>
<Text-field prompt="&gt; " style="Maple Input" layout="Normal">   	fi;</Text-field>
<Text-field prompt="&gt; " style="Maple Input" layout="Normal"></Text-field>
<Text-field prompt="&gt; " style="Maple Input" layout="Normal">    </Text-field>
<Text-field prompt="&gt; " style="Maple Input" layout="Normal">	#finaly, we are done!    </Text-field>
<Text-field prompt="&gt; " style="Maple Input" layout="Normal">    return ehrhartPoly;</Text-field>
<Text-field prompt="&gt; " style="Maple Input" layout="Normal">end:</Text-field>
<Text-field prompt="&gt; " style="Maple Input" layout="Normal"></Text-field>
<Text-field prompt="&gt; " style="Maple Input" layout="Normal"></Text-field>
<Text-field prompt="&gt; " style="Maple Input" layout="Normal"></Text-field>
<Text-field prompt="&gt; " style="Maple Input" layout="Normal"></Text-field>
<Text-field prompt="&gt; " style="Maple Input" layout="Normal">##################################################################</Text-field>
<Text-field prompt="&gt; " style="Maple Input" layout="Normal">### CODE FOR REAL DILATIONS</Text-field>
<Text-field prompt="&gt; " style="Maple Input" layout="Normal">##################################################################</Text-field>
<Text-field prompt="&gt; " style="Maple Input" layout="Normal"></Text-field>
<Text-field prompt="&gt; " style="Maple Input" layout="Normal">######################################################################&quot;&quot;&quot;&quot;</Text-field>
<Text-field prompt="&gt; " style="Maple Input" layout="Normal"># Approximate  functions  S^L  for a  dilated  cone ns+Cone; HERE n is a real.</Text-field>
<Text-field prompt="&gt; " style="Maple Input" layout="Normal"># Input: n a variable,  s a numeric vector in Q^d,</Text-field>
<Text-field prompt="&gt; " style="Maple Input" layout="Normal"># W a cone, Ispace a subset of [1,2,...d];</Text-field>
<Text-field prompt="&gt; " style="Maple Input" layout="Normal"># xi a list of variables.</Text-field>
<Text-field prompt="&gt; " style="Maple Input" layout="Normal"># Output a function f(n,N,xi);</Text-field>
<Text-field prompt="&gt; " style="Maple Input" layout="Normal"></Text-field>
<Text-field prompt="&gt; " style="Maple Input" layout="Normal">#</Text-field>
<Text-field prompt="&gt; " style="Maple Input" layout="Normal"></Text-field>
<Text-field prompt="&gt; " style="Maple Input" layout="Normal"># Output a function f(n,N,xi);  where we emphasize the dependance in n;</Text-field>
<Text-field prompt="&gt; " style="Maple Input" layout="Normal"># N is the same than n, but here the function of N are perodic;</Text-field>
<Text-field prompt="&gt; " style="Maple Input" layout="Normal"># I did that,  as we will need to pick  up a polynomial term in n, while N are then considered as constants;</Text-field>
<Text-field prompt="&gt; " style="Maple Input" layout="Normal"># EXAMPLE IS GIVEN  AFTER;</Text-field>
<Text-field prompt="&gt; " style="Maple Input" layout="Normal">#</Text-field>
<Text-field prompt="&gt; " style="Maple Input" layout="Normal">dilatedS_Ispace_Cone_real:=proc(n,s,W,ISpace,xi) local i,ss,uni_cones,function_on_Cspace,function_on_ISpace,W_projected,WW,WWW,signuni,signL,ts,j,Cspace,out1,out2,s_in_cone_coord,s_Cspace_in_cone_coord,s_small_move,M,newxi,dimL,g,testrank,newP,dilateds,</Text-field>
<Text-field prompt="&gt; " style="Maple Input" layout="Normal">    s_Cspace_in_lattice_coord,news,</Text-field>
<Text-field prompt="&gt; " style="Maple Input" layout="Normal">    ProjLattice;</Text-field>
<Text-field prompt="&gt; " style="Maple Input" layout="Normal">    Cspace:=ComplementList(ISpace,nops(W));</Text-field>
<Text-field prompt="&gt; " style="Maple Input" layout="Normal">    ProjLattice := projectedlattice(W,Cspace);</Text-field>
<Text-field prompt="&gt; " style="Maple Input" layout="Normal">    dilateds:=[seq(n*s[i],i=1..nops(W))];</Text-field>
<Text-field prompt="&gt; " style="Maple Input" layout="Normal">    s_Cspace_in_lattice_coord:=projectedvertexinbasislattice(W,Cspace,ProjLattice,s);# I keep n outside;</Text-field>
<Text-field prompt="&gt; " style="Maple Input" layout="Normal">    function_on_ISpace:=functionIb(dilateds,W,ISpace,xi);</Text-field>
<Text-field prompt="&gt; " style="Maple Input" layout="Normal">#from here express in terms of the basis lattice for projected cone.</Text-field>
<Text-field prompt="&gt; " style="Maple Input" layout="Normal">    W_projected:=projectedconeinbasislattice(W,Cspace,ProjLattice):</Text-field>
<Text-field prompt="&gt; " style="Maple Input" layout="Normal">    if W_projected=[] then</Text-field>
<Text-field prompt="&gt; " style="Maple Input" layout="Normal">        out1:=function_on_ISpace[1]/function_on_ISpace[2];</Text-field>
<Text-field prompt="&gt; " style="Maple Input" layout="Normal">    else</Text-field>
<Text-field prompt="&gt; " style="Maple Input" layout="Normal">        newxi:=changeofcoordinates(W,Cspace,ProjLattice,xi);</Text-field>
<Text-field prompt="&gt; " style="Maple Input" layout="Normal">        uni_cones:=cone_dec(W_projected);</Text-field>
<Text-field prompt="&gt; " style="Maple Input" layout="Normal">        out1:=0;</Text-field>
<Text-field prompt="&gt; " style="Maple Input" layout="Normal">        for j from 1 to nops(uni_cones) do</Text-field>
<Text-field prompt="&gt; " style="Maple Input" layout="Normal">            WWW:=uni_cones[j][3];</Text-field>
<Text-field prompt="&gt; " style="Maple Input" layout="Normal">            signuni:=uni_cones[j][1];</Text-field>
<Text-field prompt="&gt; " style="Maple Input" layout="Normal">            ASSERT(abs(uni_cones[j][2])=1, &quot;decomposition not unimodular&quot;);</Text-field>
<Text-field prompt="&gt; " style="Maple Input" layout="Normal">            newP:=MatrixInverse(Transpose(Matrix(WWW)));</Text-field>
<Text-field prompt="&gt; " style="Maple Input" layout="Normal">            news:=convert(Multiply(newP,Vector(s_Cspace_in_lattice_coord)),list); #print(&quot;news&quot;,news);</Text-field>
<Text-field prompt="&gt; " style="Maple Input" layout="Normal"></Text-field>
<Text-field prompt="&gt; " style="Maple Input" layout="Normal">            s_small_move:=[seq(nfractionalpartreal(N,-numer(news[f]),denom(news[f])),f=1..nops(news))];  #print(&quot;smallmove&quot;,s_small_move);</Text-field>
<Text-field prompt="&gt; " style="Maple Input" layout="Normal">            function_on_Cspace:=functionS(s_small_move,WWW,newxi);</Text-field>
<Text-field prompt="&gt; " style="Maple Input" layout="Normal">            out1:=out1+signuni*function_on_Cspace[1]/function_on_Cspace[2]*function_on_ISpace[1]/function_on_ISpace[2];</Text-field>
<Text-field prompt="&gt; " style="Maple Input" layout="Normal">        od:</Text-field>
<Text-field prompt="&gt; " style="Maple Input" layout="Normal">    fi;</Text-field>
<Text-field prompt="&gt; " style="Maple Input" layout="Normal">    EXP(add(n*s[i]*xi[i],i=1..nops(W)))*out1;</Text-field>
<Text-field prompt="&gt; " style="Maple Input" layout="Normal">end:</Text-field>
<Text-field prompt="&gt; " style="Maple Input" layout="Normal"></Text-field>
<Text-field prompt="&gt; " style="Maple Input" layout="Normal"></Text-field>
<Text-field prompt="&gt; " style="Maple Input" layout="Normal"></Text-field>
<Text-field prompt="&gt; " style="Maple Input" layout="Normal"></Text-field>
<Text-field prompt="&gt; " style="Maple Input" layout="Normal"></Text-field>
<Text-field prompt="&gt; " style="Maple Input" layout="Normal">random_vector:=proc(N,d) local R;</Text-field>
<Text-field prompt="&gt; " style="Maple Input" layout="Normal">    R:=rand(N);</Text-field>
<Text-field prompt="&gt; " style="Maple Input" layout="Normal">    [seq(R()+1,i=1..d)]:</Text-field>
<Text-field prompt="&gt; " style="Maple Input" layout="Normal">end:</Text-field>
<Text-field prompt="&gt; " style="Maple Input" layout="Normal"></Text-field>
<Text-field prompt="&gt; " style="Maple Input" layout="Normal"></Text-field>
<Text-field prompt="&gt; " style="Maple Input" layout="Normal"></Text-field>
<Text-field prompt="&gt; " style="Maple Input" layout="Normal">######################################################################&quot;&quot;&quot;&quot;</Text-field>
<Text-field prompt="&gt; " style="Maple Input" layout="Normal"></Text-field>
<Text-field prompt="&gt; " style="Maple Input" layout="Normal"></Text-field>
<Text-field prompt="&gt; " style="Maple Input" layout="Normal"></Text-field>
<Text-field prompt="&gt; " style="Maple Input" layout="Normal">##EXAMPLES:</Text-field>
<Text-field prompt="&gt; " style="Maple Input" layout="Normal">#VERIFICATION FOR APPROXIMATION;</Text-field>
<Text-field prompt="&gt; " style="Maple Input" layout="Normal">random_rational_vector:=proc(N,d) local R;</Text-field>
<Text-field prompt="&gt; " style="Maple Input" layout="Normal">    R:=rand(N);</Text-field>
<Text-field prompt="&gt; " style="Maple Input" layout="Normal">    [seq(R()/(R()+1),i=1..d)]:</Text-field>
<Text-field prompt="&gt; " style="Maple Input" layout="Normal">end:</Text-field>
<Text-field prompt="&gt; " style="Maple Input" layout="Normal">randomaffinecone:=proc(N,d) local S,i,c;</Text-field>
<Text-field prompt="&gt; " style="Maple Input" layout="Normal">    c:=[];</Text-field>
<Text-field prompt="&gt; " style="Maple Input" layout="Normal">    for i from 1 to d do</Text-field>
<Text-field prompt="&gt; " style="Maple Input" layout="Normal">        c:=[op(c),primitive_vector(random_vector(N,d))];</Text-field>
<Text-field prompt="&gt; " style="Maple Input" layout="Normal">    od;</Text-field>
<Text-field prompt="&gt; " style="Maple Input" layout="Normal">    [random_rational_vector(10,d),c];</Text-field>
<Text-field prompt="&gt; " style="Maple Input" layout="Normal">end:</Text-field>
<Text-field prompt="&gt; " style="Maple Input" layout="Normal">randomaffinecone(10,4);</Text-field>
<Text-field prompt="&gt; " style="Maple Input" layout="Normal">random_rational_simplex:=proc(N,d) local S,i,c;</Text-field>
<Text-field prompt="&gt; " style="Maple Input" layout="Normal">    c:=[];</Text-field>
<Text-field prompt="&gt; " style="Maple Input" layout="Normal">    for i from 1 to d+1 do</Text-field>
<Text-field prompt="&gt; " style="Maple Input" layout="Normal">        c:=[op(c),random_rational_vector(N,d)];</Text-field>
<Text-field prompt="&gt; " style="Maple Input" layout="Normal">    od;end:</Text-field>
<Text-field prompt="&gt; " style="Maple Input" layout="Normal"></Text-field>
<Text-field prompt="&gt; " style="Maple Input" layout="Normal">####################################################################</Text-field>
<Text-field prompt="&gt; " style="Maple Input" layout="Normal">## EXAMPLES OF FORMULA a) versus FORMULA b)</Text-field>
<Text-field prompt="&gt; " style="Maple Input" layout="Normal"></Text-field>
<Text-field prompt="&gt; " style="Maple Input" layout="Normal"></Text-field>
<Text-field prompt="&gt; " style="Maple Input" layout="Normal">#S_Ispace_Coneformulaa([s[1],s[2]],[[1,1],[1,-1]],[1],xi);</Text-field>
<Text-field prompt="&gt; " style="Maple Input" layout="Normal"></Text-field>
<Text-field prompt="&gt; " style="Maple Input" layout="Normal">#S_Ispace_Coneformulab([s[1],s[2]],[[1,1],[1,-1]],[1],xi);</Text-field>
<Text-field prompt="&gt; " style="Maple Input" layout="Normal"></Text-field>
<Text-field prompt="&gt; " style="Maple Input" layout="Normal"></Text-field>
<Text-field prompt="&gt; " style="Maple Input" layout="Normal"></Text-field>
<Text-field prompt="&gt; " style="Maple Input" layout="Normal">#S_Ispace_Coneformulaa([s[1],s[2],s[3]],[[1,1,1],[1,-1,0],[1,1,0]],[1],xi);</Text-field>
<Text-field prompt="&gt; " style="Maple Input" layout="Normal"></Text-field>
<Text-field prompt="&gt; " style="Maple Input" layout="Normal">#S_Ispace_Coneformulab([s[1],s[2],s[3]],[[1,1,1],[1,-1,0],[1,1,0]],[1],xi);</Text-field>
<Text-field prompt="&gt; " style="Maple Input" layout="Normal"></Text-field>
<Text-field prompt="&gt; " style="Maple Input" layout="Normal">###############################################################</Text-field>
<Text-field prompt="&gt; " style="Maple Input" layout="Normal">##########################</Text-field>
<Text-field prompt="&gt; " style="Maple Input" layout="Normal"></Text-field>
<Text-field prompt="&gt; " style="Maple Input" layout="Normal">#approx_Cone_formulab([s[1],s[2],s[3]],[[1,1,1],[1,-1,0],[1,1,0]],0,xi);</Text-field>
<Text-field prompt="&gt; " style="Maple Input" layout="Normal">#approx_Cone_formulab([s[1],s[2],s[3]],[[1,1,1],[1,-1,0],[1,1,0]],1,xi);</Text-field>
<Text-field prompt="&gt; " style="Maple Input" layout="Normal">#approx_Cone_formulab([s[1],s[2],s[3]],[[1,1,1],[1,-1,0],[1,1,0]],2,xi);</Text-field>
<Text-field prompt="&gt; " style="Maple Input" layout="Normal"></Text-field>
<Text-field prompt="&gt; " style="Maple Input" layout="Normal"></Text-field>
<Text-field prompt="&gt; " style="Maple Input" layout="Normal">##########################</Text-field>
<Text-field prompt="&gt; " style="Maple Input" layout="Normal"># VERIFICATION OF THE PROPERTY OF APPROXIMATION; BY EVALUATING IN A RANDOM VECTOR;</Text-field>
<Text-field prompt="&gt; " style="Maple Input" layout="Normal">#SEEMS CORRECT;</Text-field>
<Text-field prompt="&gt; " style="Maple Input" layout="Normal"></Text-field>
<Text-field prompt="&gt; " style="Maple Input" layout="Normal"></Text-field>
<Text-field prompt="&gt; " style="Maple Input" layout="Normal">checkapprox:=proc(s,Cone,k) local FFa,FFb,Fd,xx,xi;</Text-field>
<Text-field prompt="&gt; " style="Maple Input" layout="Normal">    xi:=random_vector(100,nops(Cone));print(xi);</Text-field>
<Text-field prompt="&gt; " style="Maple Input" layout="Normal">    xx:=[seq(t*xi[i],i=1..nops(Cone))];print(xx);</Text-field>
<Text-field prompt="&gt; " style="Maple Input" layout="Normal">    FFa:=eval(subs({TODD=Todd,EXP=exp},approx_Cone_formulaa(s,Cone,k,xx)));#print(FFa);</Text-field>
<Text-field prompt="&gt; " style="Maple Input" layout="Normal">    FFb:=eval(subs({TODD=Todd,EXP=exp},approx_Cone_formulab(s,Cone,k,xx)));#print(FFb);</Text-field>
<Text-field prompt="&gt; " style="Maple Input" layout="Normal">    Fd:=eval(subs({TODD=Todd,EXP=exp},approx_Cone_formulab(s,Cone,nops(Cone),xx)));# print(Fd);</Text-field>
<Text-field prompt="&gt; " style="Maple Input" layout="Normal">    [simplify(series(FFa-Fd,t=0,nops(Cone)+2)),simplify(series(FFb-Fd,t=0,nops(Cone)+2))];</Text-field>
<Text-field prompt="&gt; " style="Maple Input" layout="Normal">end:</Text-field>
<Text-field prompt="&gt; " style="Maple Input" layout="Normal"></Text-field>
<Text-field prompt="&gt; " style="Maple Input" layout="Normal">#checkapprox([1/2,1/2,1/3,1/4],[[1,1,-1,1],[1,2,0,0],[1,2,3,4],[1,4,5,7]],3);</Text-field>
<Text-field prompt="&gt; " style="Maple Input" layout="Normal">#Coneindex2:=[[1,1,1],[1,-1,0],[1,1,0]];</Text-field>
<Text-field prompt="&gt; " style="Maple Input" layout="Normal"></Text-field>
<Text-field prompt="&gt; " style="Maple Input" layout="Normal">#A0:=eval(subs({TODD=Todd,EXP=exp},approx_Cone_formulab([1/2,1/3,1/4],Coneindex2,0,xi)));</Text-field>
<Text-field prompt="&gt; " style="Maple Input" layout="Normal">#A1:=eval(subs({TODD=Todd,EXP=exp},approx_Cone_formulab([1/2,1/3,1/4],Coneindex2,1,xi)));</Text-field>
<Text-field prompt="&gt; " style="Maple Input" layout="Normal">#A2:=eval(subs({TODD=Todd,EXP=exp},approx_Cone_formulab([1/2,1/3,1/4],Coneindex2,2,xi)));</Text-field>
<Text-field prompt="&gt; " style="Maple Input" layout="Normal">#A3:=eval(subs({TODD=Todd,EXP=exp},approx_Cone_formulab([1/2,1/3,1/4],Coneindex2,3,xi)));</Text-field>
<Text-field prompt="&gt; " style="Maple Input" layout="Normal"></Text-field>
<Text-field prompt="&gt; " style="Maple Input" layout="Normal"></Text-field>
<Text-field prompt="&gt; " style="Maple Input" layout="Normal"></Text-field>
<Text-field prompt="&gt; " style="Maple Input" layout="Normal">#####################################################################</Text-field>
<Text-field prompt="&gt; " style="Maple Input" layout="Normal">### LATTE INTERFACE HELPER FUNCTIONS:</Text-field>
<Text-field prompt="&gt; " style="Maple Input" layout="Normal">####################################################################</Text-field>
<Text-field prompt="&gt; " style="Maple Input" layout="Normal"></Text-field>
<Text-field prompt="&gt; " style="Maple Input" layout="Normal">#### LATTE INTERFACE FUNCTION:</Text-field>
<Text-field prompt="&gt; " style="Maple Input" layout="Normal"># input:</Text-field>
<Text-field prompt="&gt; " style="Maple Input" layout="Normal">#	a: any rational number</Text-field>
<Text-field prompt="&gt; " style="Maple Input" layout="Normal">#	n: base</Text-field>
<Text-field prompt="&gt; " style="Maple Input" layout="Normal">#	return the number between [0,n) that is equal to  a mod n</Text-field>
<Text-field prompt="&gt; " style="Maple Input" layout="Normal">latteMod:=proc(a, n)</Text-field>
<Text-field prompt="&gt; " style="Maple Input" layout="Normal">	local r, x;</Text-field>
<Text-field prompt="&gt; " style="Maple Input" layout="Normal">	ASSERT(n &gt; 0);</Text-field>
<Text-field prompt="&gt; " style="Maple Input" layout="Normal">	x:=a;</Text-field>
<Text-field prompt="&gt; " style="Maple Input" layout="Normal">	while ( x &gt;= n or x &lt; 0) do</Text-field>
<Text-field prompt="&gt; " style="Maple Input" layout="Normal">		x:= x - floor(x/n)*n;</Text-field>
<Text-field prompt="&gt; " style="Maple Input" layout="Normal">	end;</Text-field>
<Text-field prompt="&gt; " style="Maple Input" layout="Normal">	return x;</Text-field>
<Text-field prompt="&gt; " style="Maple Input" layout="Normal">end:</Text-field>
<Text-field prompt="&gt; " style="Maple Input" layout="Normal"></Text-field>
<Text-field prompt="&gt; " style="Maple Input" layout="Normal"></Text-field>
<Text-field prompt="&gt; " style="Maple Input" layout="Normal">#### LATTE INTERFACE FUNCTION:</Text-field>
<Text-field prompt="&gt; " style="Maple Input" layout="Normal">#input:</Text-field>
<Text-field prompt="&gt; " style="Maple Input" layout="Normal">#	simpleCones is a list of d+1 vertex-ray cones in the form</Text-field>
<Text-field prompt="&gt; " style="Maple Input" layout="Normal">#		[[[vertex],[[ray1], ..., [rayn]]], ...]</Text-field>
<Text-field prompt="&gt; " style="Maple Input" layout="Normal">#		We assume the cones are simple, that is, we have the tangent-cones of a simplex.</Text-field>
<Text-field prompt="&gt; " style="Maple Input" layout="Normal">#	d: integer, dimension.</Text-field>
<Text-field prompt="&gt; " style="Maple Input" layout="Normal">#</Text-field>
<Text-field prompt="&gt; " style="Maple Input" layout="Normal"># return a list of just the d+1 vertices.</Text-field>
<Text-field prompt="&gt; " style="Maple Input" layout="Normal">tangentConesToSimplex:=proc(simpleCones, d)</Text-field>
<Text-field prompt="&gt; " style="Maple Input" layout="Normal">local Simplex, cone;</Text-field>
<Text-field prompt="&gt; " style="Maple Input" layout="Normal"></Text-field>
<Text-field prompt="&gt; " style="Maple Input" layout="Normal">	Simplex:=[];</Text-field>
<Text-field prompt="&gt; " style="Maple Input" layout="Normal">	for cone in simpleCones do</Text-field>
<Text-field prompt="&gt; " style="Maple Input" layout="Normal">		Simplex:=[op(Simplex), cone[1]];</Text-field>
<Text-field prompt="&gt; " style="Maple Input" layout="Normal">	end;</Text-field>
<Text-field prompt="&gt; " style="Maple Input" layout="Normal"></Text-field>
<Text-field prompt="&gt; " style="Maple Input" layout="Normal">	ASSERT(nops(Simplex) = d+1); #make sure we have a simplex.</Text-field>
<Text-field prompt="&gt; " style="Maple Input" layout="Normal">		</Text-field>
<Text-field prompt="&gt; " style="Maple Input" layout="Normal">	return Simplex;</Text-field>
<Text-field prompt="&gt; " style="Maple Input" layout="Normal">end:</Text-field>
<Text-field prompt="&gt; " style="Maple Input" layout="Normal"></Text-field>
<Text-field prompt="&gt; " style="Maple Input" layout="Normal"></Text-field>
<Text-field prompt="&gt; " style="Maple Input" layout="Normal">#### LATTE INTERFACE FUNCTION:</Text-field>
<Text-field prompt="&gt; " style="Maple Input" layout="Normal">#input</Text-field>
<Text-field prompt="&gt; " style="Maple Input" layout="Normal">#	Simplex: list of d+1 verticies</Text-field>
<Text-field prompt="&gt; " style="Maple Input" layout="Normal">#return maple-list of the tangent-cones.</Text-field>
<Text-field prompt="&gt; " style="Maple Input" layout="Normal">SimplexToTangentCones:=proc(Simplex)</Text-field>
<Text-field prompt="&gt; " style="Maple Input" layout="Normal">	local simpleCones;</Text-field>
<Text-field prompt="&gt; " style="Maple Input" layout="Normal">	local cone, rays, d, i;</Text-field>
<Text-field prompt="&gt; " style="Maple Input" layout="Normal">	</Text-field>
<Text-field prompt="&gt; " style="Maple Input" layout="Normal">	simpleCones:=[];</Text-field>
<Text-field prompt="&gt; " style="Maple Input" layout="Normal">	cone:=[];</Text-field>
<Text-field prompt="&gt; " style="Maple Input" layout="Normal">	d:=nops(Simplex)-1;</Text-field>
<Text-field prompt="&gt; " style="Maple Input" layout="Normal">	</Text-field>
<Text-field prompt="&gt; " style="Maple Input" layout="Normal">	for i from 1 to d+1 do</Text-field>
<Text-field prompt="&gt; " style="Maple Input" layout="Normal">		rays:= [seq(primitive_vector(Simplex[j]-Simplex[i]), j=1..(i-1)), seq(primitive_vector(Simplex[j]-Simplex[i]), j=(i+1)..d+1)] ;</Text-field>
<Text-field prompt="&gt; " style="Maple Input" layout="Normal">		cone:=[Simplex[i], rays ];</Text-field>
<Text-field prompt="&gt; " style="Maple Input" layout="Normal">		simpleCones:=[op(simpleCones), cone];</Text-field>
<Text-field prompt="&gt; " style="Maple Input" layout="Normal">	end;</Text-field>
<Text-field prompt="&gt; " style="Maple Input" layout="Normal">	</Text-field>
<Text-field prompt="&gt; " style="Maple Input" layout="Normal">	return simpleCones;</Text-field>
<Text-field prompt="&gt; " style="Maple Input" layout="Normal">end:</Text-field>
<Text-field prompt="&gt; " style="Maple Input" layout="Normal"></Text-field>
<Text-field prompt="&gt; " style="Maple Input" layout="Normal"></Text-field>
<Text-field prompt="&gt; " style="Maple Input" layout="Normal">#####################################################################</Text-field>
<Text-field prompt="&gt; " style="Maple Input" layout="Normal">### Functions I want to delete</Text-field>
<Text-field prompt="&gt; " style="Maple Input" layout="Normal">#####################################################################</Text-field>
<Text-field prompt="&gt; " style="Maple Input" layout="Normal"></Text-field>
<Text-field prompt="&gt; " style="Maple Input" layout="Normal"></Text-field>
<Text-field prompt="&gt; " style="Maple Input" layout="Normal"># Input: n a variable,  s a numeric vector in Q^d,</Text-field>
<Text-field prompt="&gt; " style="Maple Input" layout="Normal"># W a cone, order is an integer;</Text-field>
<Text-field prompt="&gt; " style="Maple Input" layout="Normal"># xi a list of variables.</Text-field>
<Text-field prompt="&gt; " style="Maple Input" layout="Normal"># Output a function f(n,xi);</Text-field>
<Text-field prompt="&gt; " style="Maple Input" layout="Normal"># This is the sulm of the approximate  function S^{Ispace}(ns+W)(xi), where we emphasize the dependance in n;</Text-field>
<Text-field prompt="&gt; " style="Maple Input" layout="Normal"></Text-field>
<Text-field prompt="&gt; " style="Maple Input" layout="Normal"># EXAMPLE IS GIVEN  AFTER;</Text-field>
<Text-field prompt="&gt; " style="Maple Input" layout="Normal"></Text-field>
<Text-field prompt="&gt; " style="Maple Input" layout="Normal">#</Text-field>
<Text-field prompt="&gt; " style="Maple Input" layout="Normal">dilated_approxi_cone:=proc(n,s,W,order,xi) local output,d,j,C,a,K,KK,cc,P;</Text-field>
<Text-field prompt="&gt; " style="Maple Input" layout="Normal"><Font encoding="UTF-8">    #printf(&quot;##### dilated_approxi_cone: order = %d\134n&quot;, order);</Font></Text-field>
<Text-field prompt="&gt; " style="Maple Input" layout="Normal">    output:=0;</Text-field>
<Text-field prompt="&gt; " style="Maple Input" layout="Normal">    d:=nops(W);</Text-field>
<Text-field prompt="&gt; " style="Maple Input" layout="Normal">    if order=d then</Text-field>
<Text-field prompt="&gt; " style="Maple Input" layout="Normal">        # Fast path; general code below handles this case just fine.</Text-field>
<Text-field prompt="&gt; " style="Maple Input" layout="Normal">        output:=dilatedS_Ispace_Cone(n,s,W,[],xi);</Text-field>
<Text-field prompt="&gt; " style="Maple Input" layout="Normal">    else</Text-field>
<Text-field prompt="&gt; " style="Maple Input" layout="Normal">        for j from 0 to order do</Text-field>
<Text-field prompt="&gt; " style="Maple Input" layout="Normal">            C:=choose(d,j);</Text-field>
<Text-field prompt="&gt; " style="Maple Input" layout="Normal">            #print(&quot;choose j, order, c&quot;, j, order, C);</Text-field>
<Text-field prompt="&gt; " style="Maple Input" layout="Normal">            cc[j]:=(-1)^(order-j)*binomial(d-j-1,d-order-1);</Text-field>
<Text-field prompt="&gt; " style="Maple Input" layout="Normal">            for a from 1 to nops(C) do</Text-field>
<Text-field prompt="&gt; " style="Maple Input" layout="Normal">                K:=C[a]; KK:=ComplementList(K,nops(W));</Text-field>
<Text-field prompt="&gt; " style="Maple Input" layout="Normal">                output:=output+cc[j]*dilatedS_Ispace_Cone(n,s,W,KK,xi) ;</Text-field>
<Text-field prompt="&gt; " style="Maple Input" layout="Normal">            od;</Text-field>
<Text-field prompt="&gt; " style="Maple Input" layout="Normal">        od:</Text-field>
<Text-field prompt="&gt; " style="Maple Input" layout="Normal">    fi;</Text-field>
<Text-field prompt="&gt; " style="Maple Input" layout="Normal">    output;</Text-field>
<Text-field prompt="&gt; " style="Maple Input" layout="Normal">end:</Text-field>
<Text-field prompt="&gt; " style="Maple Input" layout="Normal"></Text-field>
<Text-field prompt="&gt; " style="Maple Input" layout="Normal"># Input: n a variable,  Simplex  a numeric rational simplex ; given by a list of  rational  vectors in Q^d</Text-field>
<Text-field prompt="&gt; " style="Maple Input" layout="Normal"># order is an integer;</Text-field>
<Text-field prompt="&gt; " style="Maple Input" layout="Normal"># xi a list of variables. xi can be numeric but then there can be an error message;</Text-field>
<Text-field prompt="&gt; " style="Maple Input" layout="Normal"># Output a function f(n,N,xi);</Text-field>
<Text-field prompt="&gt; " style="Maple Input" layout="Normal"># This is the sum of the approximate  functions  over the tangent cones  for the dilated simplex nS; where we emphasize the dependance in n;</Text-field>
<Text-field prompt="&gt; " style="Maple Input" layout="Normal"># N is the same as n, but here the functions of N are periodic;</Text-field>
<Text-field prompt="&gt; " style="Maple Input" layout="Normal"># I did that, as we will need to pick up a polynomial term in n, while N are then considered as constants;</Text-field>
<Text-field prompt="&gt; " style="Maple Input" layout="Normal"># EXAMPLE IS GIVEN  AFTER;</Text-field>
<Text-field prompt="&gt; " style="Maple Input" layout="Normal"></Text-field>
<Text-field prompt="&gt; " style="Maple Input" layout="Normal">#</Text-field>
<Text-field prompt="&gt; " style="Maple Input" layout="Normal">ApproxEhrhartSimplexgeneric:=proc(n,Simplex,order,xi) local F,W,i,st,d,S,y,P;</Text-field>
<Text-field prompt="&gt; " style="Maple Input" layout="Normal">    F:=0;  S:=Simplex;</Text-field>
<Text-field prompt="&gt; " style="Maple Input" layout="Normal">    d:=nops(S)-1;</Text-field>
<Text-field prompt="&gt; " style="Maple Input" layout="Normal">    for i from 1 to nops(S) do</Text-field>
<Text-field prompt="&gt; " style="Maple Input" layout="Normal">        W:=[seq(primitive_vector(S[j]-S[i]),j=1..i-1),seq(primitive_vector(S[j]-S[i]),j=i+1..nops(S))];</Text-field>
<Text-field prompt="&gt; " style="Maple Input" layout="Normal">        F:=F+dilated_approxi_cone(n,S[i],W,order,xi) ;
#print(i,S[i],W,eval(subs({TODD=Todd,EXP=exp},dilated_approxi_cone(n,S[i],W,order,xi))));</Text-field>
<Text-field prompt="&gt; " style="Maple Input" layout="Normal">    od:
</Text-field>
<Text-field prompt="&gt; " style="Maple Input" layout="Normal">    F:=eval(subs({TODD=Todd,EXP=exp},F));</Text-field>
<Text-field prompt="&gt; " style="Maple Input" layout="Normal">    </Text-field>
<Text-field prompt="&gt; " style="Maple Input" layout="Normal">    return F;</Text-field>
<Text-field prompt="&gt; " style="Maple Input" layout="Normal">end:</Text-field>
<Text-field prompt="&gt; " style="Maple Input" layout="Normal"></Text-field>
<Text-field prompt="&gt; " style="Maple Input" layout="Normal">#WARNING; THIS WORKS ONLY IF ell is generic;</Text-field>
<Text-field prompt="&gt; " style="Maple Input" layout="Normal"># Input; n is a variable, Simplex is a rational simplex, ell is a linear form fiven as a numeric list of d+1 rational numbers; M is in integer, m is an integer.</Text-field>
<Text-field prompt="&gt; " style="Maple Input" layout="Normal"># The ouput is  a periodic function of n;</Text-field>
<Text-field prompt="&gt; " style="Maple Input" layout="Normal"># Math: the output is the m coefficient Ehrhart polynomial E(n S, ell^M)</Text-field>
<Text-field prompt="&gt; " style="Maple Input" layout="Normal"># Here I did not employ a deformation vector, so the procedure might return: error; diviasion by zero.</Text-field>
<Text-field prompt="&gt; " style="Maple Input" layout="Normal">#</Text-field>
<Text-field prompt="&gt; " style="Maple Input" layout="Normal">TopEhrhartweightedluckyell:=proc(n,Simplex,ell,M,m) local d,order,xx,AA,CC;</Text-field>
<Text-field prompt="&gt; " style="Maple Input" layout="Normal">    d:=nops(Simplex)-1;</Text-field>
<Text-field prompt="&gt; " style="Maple Input" layout="Normal">    order:=M+d-m;</Text-field>
<Text-field prompt="&gt; " style="Maple Input" layout="Normal">    xx:=[seq(t*ell[i],i=1..d)];</Text-field>
<Text-field prompt="&gt; " style="Maple Input" layout="Normal">    AA:=ApproxEhrhartSimplexgeneric(n,Simplex,order,xx);</Text-field>
<Text-field prompt="&gt; " style="Maple Input" layout="Normal">    CC:=coeff(coeff(series(AA,t=0,M+d+2),t,M),n,m);</Text-field>
<Text-field prompt="&gt; " style="Maple Input" layout="Normal">    subs({N=n},CC);</Text-field>
<Text-field prompt="&gt; " style="Maple Input" layout="Normal">end:</Text-field>
<Text-field prompt="&gt; " style="Maple Input" layout="Normal"># Input; n is a variable, Simplex is a rational simplex, ell is a linear form fiven as a numeric list of d+1 rational numbers; M is in integer, m is an integer.</Text-field>
<Text-field prompt="&gt; " style="Maple Input" layout="Normal"># The ouput is  a periodic function of n;</Text-field>
<Text-field prompt="&gt; " style="Maple Input" layout="Normal"># Math: the output is the m coefficient Ehrhart polynomial E(n S, ell^M)</Text-field>
<Text-field prompt="&gt; " style="Maple Input" layout="Normal"># Here we employ a random deformation vector, so if the procedure might return: error: division by zero. RERUN:</Text-field>
<Text-field prompt="&gt; " style="Maple Input" layout="Normal">#</Text-field>
<Text-field prompt="&gt; " style="Maple Input" layout="Normal">#</Text-field>
<Text-field prompt="&gt; " style="Maple Input" layout="Normal">TopEhrhartweighted:=proc(n,Simplex,ell,M,m) local d,order,xx,AA,CCt,CCeps,CCn,reg;</Text-field>
<Text-field prompt="&gt; " style="Maple Input" layout="Normal">    d:=nops(Simplex)-1;</Text-field>
<Text-field prompt="&gt; " style="Maple Input" layout="Normal">    order:=M+d-m;</Text-field>
<Text-field prompt="&gt; " style="Maple Input" layout="Normal">    reg:=random_vector(5000,d);</Text-field>
<Text-field prompt="&gt; " style="Maple Input" layout="Normal">    xx:=[seq(t*(ell[i]+epsilon*reg[i]),i=1..d)];</Text-field>
<Text-field prompt="&gt; " style="Maple Input" layout="Normal">    AA:=ApproxEhrhartSimplexgeneric(n,Simplex,order,xx);</Text-field>
<Text-field prompt="&gt; " style="Maple Input" layout="Normal">    CCeps:=coeff(series(CCt,epsilon=0,d+2),epsilon,0);</Text-field>
<Text-field prompt="&gt; " style="Maple Input" layout="Normal">    CCn:=coeff(CCeps,n,m);</Text-field>
<Text-field prompt="&gt; " style="Maple Input" layout="Normal">    return subs({N=n},CCn);</Text-field>
<Text-field prompt="&gt; " style="Maple Input" layout="Normal">end:</Text-field>
<Text-field prompt="&gt; " style="Maple Input" layout="Normal"># Input; n is a variable, Simplex is a rational simplex, ell is a linear form fiven as a numeric list of d+1 rational numbers; M is in integer, m is an integer.</Text-field>
<Text-field prompt="&gt; " style="Maple Input" layout="Normal"># The ouput is  a polynomial with coefficients  periodic function of n;</Text-field>
<Text-field prompt="&gt; " style="Maple Input" layout="Normal"># Math: the output is Ehrhart polynomial E(n S, ell^M)</Text-field>
<Text-field prompt="&gt; " style="Maple Input" layout="Normal"># Here we employ a random deformation vector, so if the procedure might return: error; diviasion by zero. RERUN:</Text-field>
<Text-field prompt="&gt; " style="Maple Input" layout="Normal">#</Text-field>
<Text-field prompt="&gt; " style="Maple Input" layout="Normal">#</Text-field>
<Text-field prompt="&gt; " style="Maple Input" layout="Normal">#</Text-field>
<Text-field prompt="&gt; " style="Maple Input" layout="Normal">CompleteEhrhartweighted:=proc(n,Simplex,ell,M) local d;</Text-field>
<Text-field prompt="&gt; " style="Maple Input" layout="Normal">    d:=nops(Simplex)-1;</Text-field>
<Text-field prompt="&gt; " style="Maple Input" layout="Normal">    add(TopEhrhartweighted(n,Simplex,ell,M,m)*n^m,m=0..M+d);</Text-field>
<Text-field prompt="&gt; " style="Maple Input" layout="Normal">end:</Text-field>
<Text-field prompt="&gt; " style="Maple Input" layout="Normal">thefirstk0Ehrhartweighted:=proc(n,Simplex,ell,M,k0) local d;</Text-field>
<Text-field prompt="&gt; " style="Maple Input" layout="Normal">    d:=nops(Simplex)-1;</Text-field>
<Text-field prompt="&gt; " style="Maple Input" layout="Normal">    add(TopEhrhartweighted(n,Simplex,ell,M,m)*n^m,m=M+d-k0..M+d);</Text-field>
<Text-field prompt="&gt; " style="Maple Input" layout="Normal">end:</Text-field>
<Text-field prompt="&gt; " style="Maple Input" layout="Normal"></Text-field>
<Text-field prompt="&gt; " style="Maple Input" layout="Normal">#####################################################################</Text-field>
<Text-field prompt="&gt; " style="Maple Input" layout="Normal">### real Functions I want to delete</Text-field>
<Text-field prompt="&gt; " style="Maple Input" layout="Normal">#####################################################################</Text-field>
<Text-field prompt="&gt; " style="Maple Input" layout="Normal"></Text-field>
<Text-field prompt="&gt; " style="Maple Input" layout="Normal"></Text-field>
<Text-field prompt="&gt; " style="Maple Input" layout="Normal">dilated_approxi_cone_real:=proc(n,s,W,order,xi) local output,d,j,C,a,K,KK,cc,P;</Text-field>
<Text-field prompt="&gt; " style="Maple Input" layout="Normal">    output:=0;</Text-field>
<Text-field prompt="&gt; " style="Maple Input" layout="Normal">    d:=nops(W);</Text-field>
<Text-field prompt="&gt; " style="Maple Input" layout="Normal">    if order=d then</Text-field>
<Text-field prompt="&gt; " style="Maple Input" layout="Normal">        output:=dilatedS_Ispace_Cone_real(n,s,W,[],xi);</Text-field>
<Text-field prompt="&gt; " style="Maple Input" layout="Normal">    else</Text-field>
<Text-field prompt="&gt; " style="Maple Input" layout="Normal">        for j from 0 to order do</Text-field>
<Text-field prompt="&gt; " style="Maple Input" layout="Normal">            C:=choose(d,j);</Text-field>
<Text-field prompt="&gt; " style="Maple Input" layout="Normal">            cc[j]:=(-1)^(order-j)*binomial(d-j-1,d-order-1);</Text-field>
<Text-field prompt="&gt; " style="Maple Input" layout="Normal">            for a from 1 to nops(C) do</Text-field>
<Text-field prompt="&gt; " style="Maple Input" layout="Normal">                K:=C[a]; KK:=ComplementList(K,nops(W));</Text-field>
<Text-field prompt="&gt; " style="Maple Input" layout="Normal">                output:=output+cc[j]*dilatedS_Ispace_Cone_real(n,s,W,KK,xi) ;</Text-field>
<Text-field prompt="&gt; " style="Maple Input" layout="Normal">            od;</Text-field>
<Text-field prompt="&gt; " style="Maple Input" layout="Normal">        od:</Text-field>
<Text-field prompt="&gt; " style="Maple Input" layout="Normal">    fi;</Text-field>
<Text-field prompt="&gt; " style="Maple Input" layout="Normal">    output;</Text-field>
<Text-field prompt="&gt; " style="Maple Input" layout="Normal">end:</Text-field>
<Text-field prompt="&gt; " style="Maple Input" layout="Normal"></Text-field>
<Text-field prompt="&gt; " style="Maple Input" layout="Normal">ApproxEhrhartSimplexgeneric_real:=proc(n,Simplex,order,xi) local F,W,i,st,d,S,y,P;</Text-field>
<Text-field prompt="&gt; " style="Maple Input" layout="Normal">    F:=0;  S:=Simplex;</Text-field>
<Text-field prompt="&gt; " style="Maple Input" layout="Normal">    d:=nops(S)-1;</Text-field>
<Text-field prompt="&gt; " style="Maple Input" layout="Normal">    for i from 1 to nops(S) do</Text-field>
<Text-field prompt="&gt; " style="Maple Input" layout="Normal">        W:=[seq(primitive_vector(S[j]-S[i]),j=1..i-1),seq(primitive_vector(S[j]-S[i]),j=i+1..nops(S))];</Text-field>
<Text-field prompt="&gt; " style="Maple Input" layout="Normal">        F:=F+dilated_approxi_cone_real(n,S[i],W,order,xi) ;</Text-field>
<Text-field prompt="&gt; " style="Maple Input" layout="Normal">    od:</Text-field>
<Text-field prompt="&gt; " style="Maple Input" layout="Normal">    F:=eval(subs({TODD=Todd,EXP=exp},F));</Text-field>
<Text-field prompt="&gt; " style="Maple Input" layout="Normal">end:</Text-field>
<Text-field prompt="&gt; " style="Maple Input" layout="Normal"></Text-field>
<Text-field prompt="&gt; " style="Maple Input" layout="Normal"></Text-field>
<Text-field prompt="&gt; " style="Maple Input" layout="Normal">#WARNING; THIS WORKS ONLY IF ell is generic;</Text-field>
<Text-field prompt="&gt; " style="Maple Input" layout="Normal">TopEhrhartweightedluckyell_real:=proc(n,Simplex,ell,M,m) local d,order,xx,AA,CC;</Text-field>
<Text-field prompt="&gt; " style="Maple Input" layout="Normal">    d:=nops(Simplex)-1;</Text-field>
<Text-field prompt="&gt; " style="Maple Input" layout="Normal">    order:=M+d-m;</Text-field>
<Text-field prompt="&gt; " style="Maple Input" layout="Normal">    xx:=[seq(t*ell[i],i=1..d)];</Text-field>
<Text-field prompt="&gt; " style="Maple Input" layout="Normal">    AA:=ApproxEhrhartSimplexgeneric_real(n,Simplex,order,xx);</Text-field>
<Text-field prompt="&gt; " style="Maple Input" layout="Normal">    CC:=coeff(coeff(series(AA,t=0,M+d+2),t,M),n,m);</Text-field>
<Text-field prompt="&gt; " style="Maple Input" layout="Normal">    subs({N=n},CC);</Text-field>
<Text-field prompt="&gt; " style="Maple Input" layout="Normal">end:</Text-field>
<Text-field prompt="&gt; " style="Maple Input" layout="Normal"></Text-field>
<Text-field prompt="&gt; " style="Maple Input" layout="Normal">TopEhrhartweighted_real:=proc(n,Simplex,ell,M,m) local d,order,xx,AA,CCt,CCeps,CCn,reg;</Text-field>
<Text-field prompt="&gt; " style="Maple Input" layout="Normal">    d:=nops(Simplex)-1;</Text-field>
<Text-field prompt="&gt; " style="Maple Input" layout="Normal">    order:=M+d-m;</Text-field>
<Text-field prompt="&gt; " style="Maple Input" layout="Normal">    reg:=random_vector(1000,d);</Text-field>
<Text-field prompt="&gt; " style="Maple Input" layout="Normal">    xx:=[seq(t*(ell[i]+epsilon*reg[i]),i=1..d)];</Text-field>
<Text-field prompt="&gt; " style="Maple Input" layout="Normal">    AA:=ApproxEhrhartSimplexgeneric_real(n,Simplex,order,xx);</Text-field>
<Text-field prompt="&gt; " style="Maple Input" layout="Normal">    CCt:=coeff(series(AA,t=0,M+d+2),t,M); #print(CCt);</Text-field>
<Text-field prompt="&gt; " style="Maple Input" layout="Normal">    CCeps:=coeff(series(CCt,epsilon=0,d+2),epsilon,0);</Text-field>
<Text-field prompt="&gt; " style="Maple Input" layout="Normal">    CCn:=coeff(CCeps,n,m);</Text-field>
<Text-field prompt="&gt; " style="Maple Input" layout="Normal">    subs({N=n},CCn);</Text-field>
<Text-field prompt="&gt; " style="Maple Input" layout="Normal">end:</Text-field>
<Text-field prompt="&gt; " style="Maple Input" layout="Normal">CompleteEhrhartweighted_real:=proc(n,nn,Simplex,ell,M) local d;</Text-field>
<Text-field prompt="&gt; " style="Maple Input" layout="Normal">    d:=nops(Simplex)-1;</Text-field>
<Text-field prompt="&gt; " style="Maple Input" layout="Normal">    add(TopEhrhartweighted_real(n,Simplex,ell,M,m)*nn^m,m=0..M+d);</Text-field>
<Text-field prompt="&gt; " style="Maple Input" layout="Normal">end:</Text-field>
<Text-field prompt="&gt; " style="Maple Input" layout="Normal"></Text-field>
<Text-field prompt="&gt; " style="Maple Input" layout="Normal"></Text-field>
</Input>
<Input>
<Text-field prompt="&gt; " style="Maple Input" alignment="left" firstindent="0" spacebelow="0" leftmargin="0" linespacing="0.0" initial="0" linebreak="space" rightmargin="0" bulletsuffix="" spaceabove="0" bullet="none" pagebreak-before="false"></Text-field>
</Input>
<Output>
<Text-field style="2D Output" layout="Maple Output"><Equation executable="false" style="2D Output" display="LUklbXJvd0c2Iy9JK21vZHVsZW5hbWVHNiJJLFR5cGVzZXR0aW5nR0koX3N5c2xpYkdGJzYlLUkjbW9HRiQ2LVEqJnVtaW51czA7RicvJSxtYXRodmFyaWFudEdRJ25vcm1hbEYnLyUmZmVuY2VHUSZmYWxzZUYnLyUqc2VwYXJhdG9yR0Y0LyUpc3RyZXRjaHlHRjQvJSpzeW1tZXRyaWNHRjQvJShsYXJnZW9wR0Y0LyUubW92YWJsZWxpbWl0c0dGNC8lJ2FjY2VudEdGNC8lJ2xzcGFjZUdRLDAuMjIyMjIyMmVtRicvJSdyc3BhY2VHRkMtSSZtZnJhY0dGJDYoLUYjNiYtRiM2Ji1JI21pR0YkNiVRJEVYUEYnLyUnaXRhbGljR1EldHJ1ZUYnL0YwUSdpdGFsaWNGJy1GLDYtUTAmQXBwbHlGdW5jdGlvbjtGJ0YvRjJGNUY3RjlGO0Y9Rj8vRkJRJjAuMGVtRicvRkVGWi1JKG1mZW5jZWRHRiQ2JC1GIzYmLUYjNiYtRk42JVEjczFGJ0ZRRlQtRiw2LVExJkludmlzaWJsZVRpbWVzO0YnRi9GMkY1RjdGOUY7Rj1GP0ZZRmVuLUklbXN1YkdGJDYlLUZONiVRJSZ4aTtGJy9GUkY0Ri8tSSNtbkdGJDYkUSIxRidGLy8lL3N1YnNjcmlwdHNoaWZ0R1EiMEYnRi8tRiw2LVEnJnBsdXM7RidGL0YyRjVGN0Y5RjtGPUY/RkFGRC1GIzYmLUZONiVRI3MyRidGUUZURmBvLUZkbzYlRmZvLUZbcDYkUSIyRidGL0ZecEYvRi9GL0YvRmBvLUYjNiYtRk42JVElVE9EREYnRlFGVEZWLUZnbjYkLUYjNigtRiM2Ji1GTjYlUSVmcmFjRidGaW9GL0ZWLUZnbjYkLUYjNiVGK0ZmcEYvRi9GLy1GLDYtUSIsRidGL0YyL0Y2RlNGN0Y5RjtGPUY/RlkvRkVRLDAuMzMzMzMzM2VtRictRiM2Ji1GRzYoRmNvRltxLyUubGluZXRoaWNrbmVzc0dGXXAvJStkZW5vbWFsaWduR1EnY2VudGVyRicvJSludW1hbGlnbkdGXnMvJSliZXZlbGxlZEdGNEZhcEZpcEYvLyUrZm9yZWdyb3VuZEdRKFswLDAsMF1GJy8lKXJlYWRvbmx5R0Y0Ri9GL0YvRi8tRiM2Ji1GZ242JEZmckYvRmBvRmNvRi9GanJGXHNGX3NGYXNGLw==">LCQqKi1JJEVYUEc2IjYjLCYqJkkjczFHRiYiIiImSSN4aUdGJjYjRitGK0YrKiZJI3MyR0YmRismRi02IyIiI0YrRitGKy1JJVRPRERHRiY2JC1JJWZyYWNHNiQlKnByb3RlY3RlZEdJKF9zeXNsaWJHRiY2IywkRjAhIiIsJiomI0YrRjNGK0YsRitGK0YxRitGK0Y/Rj5GLEY+Rj4=</Equation></Text-field>
</Output>
<Output>
<Text-field style="2D Output" layout="Maple Output"><Equation executable="false" style="2D Output" display="LUklbXJvd0c2Iy9JK21vZHVsZW5hbWVHNiJJLFR5cGVzZXR0aW5nR0koX3N5c2xpYkdGJzY1LUkjbW9HRiQ2LVEqJnVtaW51czA7RicvJSxtYXRodmFyaWFudEdRJ25vcm1hbEYnLyUmZmVuY2VHUSZmYWxzZUYnLyUqc2VwYXJhdG9yR0Y0LyUpc3RyZXRjaHlHRjQvJSpzeW1tZXRyaWNHRjQvJShsYXJnZW9wR0Y0LyUubW92YWJsZWxpbWl0c0dGNC8lJ2FjY2VudEdGNC8lJ2xzcGFjZUdRLDAuMjIyMjIyMmVtRicvJSdyc3BhY2VHRkMtSSZtZnJhY0dGJDYoLUkjbW5HRiQ2JFEiMUYnRi8tRiM2Ji1JJW1zdWJHRiQ2JS1JI21pR0YkNiVRJSZ4aTtGJy8lJ2l0YWxpY0dGNEYvRkkvJS9zdWJzY3JpcHRzaGlmdEdRIjBGJy1GLDYtUTEmSW52aXNpYmxlVGltZXM7RidGL0YyRjVGN0Y5RjtGPUY/L0ZCUSYwLjBlbUYnL0ZFRmluLUZQNiVGUi1GSjYkUSIyRidGL0ZYRi8vJS5saW5ldGhpY2tuZXNzR0ZMLyUrZGVub21hbGlnbkdRJ2NlbnRlckYnLyUpbnVtYWxpZ25HRmRvLyUpYmV2ZWxsZWRHRjQtRiw2LVEoJm1pbnVzO0YnRi9GMkY1RjdGOUY7Rj1GP0ZBRkQtRkc2KEZJLUYjNiYtSShtZmVuY2VkR0YkNiQtRiM2JkZJRmlvLUklbXN1cEdGJDYlLUYsNi1RLyZFeHBvbmVudGlhbEU7RidGL0YyRjVGN0Y5RjtGPUY/RmhuL0ZFUSwwLjExMTExMTFlbUYnRk8vJTFzdXBlcnNjcmlwdHNoaWZ0R0ZaRi9GL0ZlbkZbb0YvRmBvRmJvRmVvRmdvRmlvLUZHNihGSS1GIzYmLUZhcDYkLUYjNiZGSUZpby1GZnA2JUZocEZbb0ZdcUYvRi9GZW5GT0YvRmBvRmJvRmVvRmdvLUYsNi1RJyZwbHVzO0YnRi9GMkY1RjdGOUY7Rj1GP0ZBRkQtRkc2KEZlcC1GIzYmRk9GZW4tRmFwNiQtRiM2J0YrRk9GaXFGW29GL0YvRi9GYG9GYm9GZW9GZ29GaXEtRkc2KEZlcC1GIzYmLUZhcDYkLUYjNiZGSUZpby1GZnA2JUZocC1GIzYlRitGT0YvRl1xRi9GL0Zlbi1GYXA2JC1GIzYmRk9GaW9GW29GL0YvRi9GYG9GYm9GZW9GZ29GaXEtRkc2KEZlcC1GIzYmLUZhcDYkLUYjNiZGSUZpby1GZnA2JUZocEZickZdcUYvRi9GZW5GT0YvRmBvRmJvRmVvRmdvRmlxLUZHNihGZ3EtRiM2JkZbb0ZlbkZgc0YvRmBvRmJvRmVvRmdvRmlxLUZHNihGZ3EtRiM2Ji1GYXA2JC1GIzYmRklGaW8tRmZwNiVGaHAtRiM2JUYrRltvRi9GXXFGL0YvRmVuRmByRi9GYG9GYm9GZW9GZ29GaXEtRkc2KEZncS1GIzYmLUZhcDYkLUYjNiZGSUZpby1GZnA2JUZocEZic0ZdcUYvRi9GZW5GW29GL0Zgb0Zib0Zlb0Znb0Yv">LDQqJiZJI3hpRzYiNiMiIiIhIiImRiU2IyIiI0YpRikqJiwmRihGKC1JJGV4cEc2JCUqcHJvdGVjdGVkR0koX3N5c2xpYkdGJjYjRiRGKUYpRipGKUYpKiYsJkYoRigtRjA2I0YqRilGKUYkRilGKSooRi9GKEYkRiksJkYkRilGKkYoRilGKCooRi9GKCwmRihGKC1GMDYjLCRGJEYpRilGKSwmRiRGKEYqRilGKUYoKihGL0YoLCZGKEYoLUYwNiNGOkYpRilGJEYpRigqKEY3RihGKkYpRkBGKUYoKihGN0YoLCZGKEYoLUYwNiMsJEYqRilGKUYpRjpGKUYoKihGN0YoLCZGKEYoLUYwNiNGQEYpRilGKkYpRig=</Equation></Text-field>
</Output>
<Output>
<Text-field style="2D Output" layout="Maple Output"><Equation executable="false" style="2D Output" display="LUkobWZlbmNlZEc2Iy9JK21vZHVsZW5hbWVHNiJJLFR5cGVzZXR0aW5nR0koX3N5c2xpYkdGJzYmLUklbXJvd0dGJDYoLUYjNiYtRiw2LC1JJm1mcmFjR0YkNigtSSNtbkdGJDYkUSI0RicvJSxtYXRodmFyaWFudEdRJ25vcm1hbEYnLUY2NiRRIjVGJ0Y5LyUubGluZXRoaWNrbmVzc0dRIjFGJy8lK2Rlbm9tYWxpZ25HUSdjZW50ZXJGJy8lKW51bWFsaWduR0ZELyUpYmV2ZWxsZWRHUSZmYWxzZUYnLUkjbW9HRiQ2LVEiLEYnRjkvJSZmZW5jZUdGSS8lKnNlcGFyYXRvckdRJXRydWVGJy8lKXN0cmV0Y2h5R0ZJLyUqc3ltbWV0cmljR0ZJLyUobGFyZ2VvcEdGSS8lLm1vdmFibGVsaW1pdHNHRkkvJSdhY2NlbnRHRkkvJSdsc3BhY2VHUSYwLjBlbUYnLyUncnNwYWNlR1EsMC4zMzMzMzMzZW1GJy1GMzYoLUY2NiRGQUY5LUY2NiRRIjhGJ0Y5Rj9GQkZFRkdGSkZfb0ZKLUY2NiRRIjBGJ0Y5LyUrZm9yZWdyb3VuZEdRKFswLDAsMF1GJy8lKXJlYWRvbmx5R0ZJRjlGOS8lJW9wZW5HUScmbHNxYjtGJy8lJmNsb3NlR1EnJnJzcWI7RidGSi1GIzYmLUYsNiwtRiM2Ji1GLDYsLUY2NiRRIjdGJ0Y5RkotRjY2JFEjMTBGJ0Y5RkotRjY2JFEiNkYnRjlGSi1GNjYkUSIyRidGOUZnb0Zqb0Y5RjlGXHBGX3BGSi1GIzYmLUYsNixGNUZKRmBxRkpGPEZKRl9vRmdvRmpvRjlGOUZccEZfcEZKLUYjNiYtRiw2LEZhb0ZKRjxGSkZdcUZKRmNxRmdvRmpvRjlGOUZccEZfcEZKLUYjNiYtRiw2LEZjcUZKRjVGSkZhb0ZKLUY2NiRRIjNGJ0Y5RmdvRmpvRjlGOUZccEZfcEZnb0Zqb0Y5RjlGXHBGX3BGZ29Gam9GOUY5RlxwRl9w">NyQ3JiMiIiUiIiYjIiIiIiIpRigiIiE3JjcmIiIoIiM1IiInIiIjNyZGJUYvRiZGKDcmRilGJkYuRjA3JkYwRiVGKSIiJA==</Equation></Text-field>
</Output>
</Group>
<Group labelreference="L13" drawlabel="true">
<Input>
<Text-field prompt="&gt; " style="Maple Input" layout="Normal">cone_by_cone:=proc(Simplex,ell,M,order) local reg,d,xx,AA,CCt,CCeps,CCn;
d:=nops(Simplex)-1;CCn:=0;
#order:=M+nops(Simplex)-codim; 
reg:=random_vector(5000,d); 
xx:=[seq(t*(ell[i]+epsilon*reg[i]),i=1..d)];
AA:=ApproxEhrhartSimplexgeneric(n,Simplex,order,xx);
CCt:=coeff(series(AA,t=0,M+d+2),t,M); 
CCeps:=coeff(series(CCt,epsilon=0,d+2),epsilon,0);
CCn:=add(coeff(CCeps,n,m)*t^(m),m=0..M+d);
subs({N=n},CCn);
end:</Text-field>
</Input>
<Input>
<Text-field prompt="&gt; " style="Maple Input" alignment="left" firstindent="0" spacebelow="0" leftmargin="0" linespacing="0.0" initial="0" linebreak="space" rightmargin="0" bulletsuffix="" spaceabove="0" bullet="none" pagebreak-before="false"></Text-field>
</Input>
</Group>
<Group labelreference="L91" drawlabel="true">
<Input>
<Text-field prompt="&gt; " style="Maple Input" layout="Normal">cone_by_cone_real:=proc(Simplex,ell,M,order) local reg,d,xx,AA,CCt,CCeps,CCn,newCCn;
d:=nops(Simplex)-1;CCn:=0;
#order:=M+nops(Simplex)-codim; 
reg:=random_vector(5000,d); 
xx:=[seq(t*(ell[i]+epsilon*reg[i]),i=1..d)];
AA:=ApproxEhrhartSimplexgeneric_real(n,Simplex,order,xx);
CCt:=coeff(series(AA,t=0,M+d+2),t,M); 
CCeps:=coeff(series(CCt,epsilon=0,d+2),epsilon,0);
CCn:=add(coeff(CCeps,n,m)*t^(m),m=0..M+d);
newCCn:=subs({N=n},CCn);subs(n=t,newCCn);
end:</Text-field>
</Input>
</Group>
<Group labelreference="L8" drawlabel="true">
<Input>
<Text-field prompt="&gt; " style="Maple Input" layout="Normal">Sstandard:=proc(n) local ze, S,j,zej; ze:=[seq(0,i=1..n)];
S:=[ze];
for j from 1 to n do zej:=subsop(j=1,ze);;
 S:=[op(S),zej];
od;
end:</Text-field>
</Input>
</Group>
<Group labelreference="L20" drawlabel="true">
<Input>
<Text-field prompt="&gt; " style="Maple Input" layout="Normal">A:=[[1,1],[1,2],[2,2]];</Text-field>
</Input>
<Output>
<Text-field style="2D Output" layout="Maple Output"><Equation executable="false" style="2D Output" display="LUklbXJvd0c2Iy9JK21vZHVsZW5hbWVHNiJJLFR5cGVzZXR0aW5nR0koX3N5c2xpYkdGJzYmLUkjbWlHRiQ2JVEiQUYnLyUnaXRhbGljR1EldHJ1ZUYnLyUsbWF0aHZhcmlhbnRHUSdpdGFsaWNGJy1JI21vR0YkNi1RKSZBc3NpZ247RicvRjNRJ25vcm1hbEYnLyUmZmVuY2VHUSZmYWxzZUYnLyUqc2VwYXJhdG9yR0Y9LyUpc3RyZXRjaHlHRj0vJSpzeW1tZXRyaWNHRj0vJShsYXJnZW9wR0Y9LyUubW92YWJsZWxpbWl0c0dGPS8lJ2FjY2VudEdGPS8lJ2xzcGFjZUdRLDAuMjc3Nzc3OGVtRicvJSdyc3BhY2VHRkwtSShtZmVuY2VkR0YkNiYtRiM2Ki1GUDYmLUYjNigtSSNtbkdGJDYkUSIxRidGOS1GNjYtUSIsRidGOUY7L0Y/RjFGQEZCRkRGRkZIL0ZLUSYwLjBlbUYnL0ZOUSwwLjMzMzMzMzNlbUYnRlgvJStmb3JlZ3JvdW5kR1EoWzAsMCwwXUYnLyUpcmVhZG9ubHlHRj1GOUY5LyUlb3BlbkdRJyZsc3FiO0YnLyUmY2xvc2VHUScmcnNxYjtGJ0Zmbi1GUDYmLUYjNihGWEZmbi1GWTYkUSIyRidGOUZeb0Zhb0Y5RjlGY29GZm9GZm4tRlA2Ji1GIzYoRl1wRmZuRl1wRl5vRmFvRjlGOUZjb0Zmb0Zeb0Zhb0Y5RjlGY29GZm9GOQ==">LV9JLFR5cGVzZXR0aW5nRzYkJSpwcm90ZWN0ZWRHSShfc3lzbGliRzYiSSxtcHJpbnRzbGFzaEdGKDYkNyM+SSJBR0YoNyU3JCIiIkYwNyRGMCIiIzckRjJGMjcjRi4=</Equation></Text-field>
</Output>
</Group>
<Group labelreference="L96" drawlabel="true">
<Input>
<Text-field prompt="&gt; " style="Maple Input" layout="Normal">A1:=cone_by_cone_real(A,[1,1],0,1);</Text-field>
</Input>
<Output>
<Text-field style="2D Output" layout="Maple Output"><Equation executable="false" style="2D Output" display="LUklbXJvd0c2Iy9JK21vZHVsZW5hbWVHNiJJLFR5cGVzZXR0aW5nR0koX3N5c2xpYkdGJzYyLUkjbWlHRiQ2JVEjQTFGJy8lJ2l0YWxpY0dRJXRydWVGJy8lLG1hdGh2YXJpYW50R1EnaXRhbGljRictSSNtb0dGJDYtUSkmQXNzaWduO0YnL0YzUSdub3JtYWxGJy8lJmZlbmNlR1EmZmFsc2VGJy8lKnNlcGFyYXRvckdGPS8lKXN0cmV0Y2h5R0Y9LyUqc3ltbWV0cmljR0Y9LyUobGFyZ2VvcEdGPS8lLm1vdmFibGVsaW1pdHNHRj0vJSdhY2NlbnRHRj0vJSdsc3BhY2VHUSwwLjI3Nzc3NzhlbUYnLyUncnNwYWNlR0ZMLUkmbWZyYWNHRiQ2KC1JJW1zdXBHRiQ2JS1GIzYmLUYsNiVRJWZyYWNGJy9GMEY9RjktRjY2LVEwJkFwcGx5RnVuY3Rpb247RidGOUY7Rj5GQEZCRkRGRkZIL0ZLUSYwLjBlbUYnL0ZORmluLUkobWZlbmNlZEdGJDYkLUYjNiYtSSNtbkdGJDYkUSIyRidGOS1GNjYtUTEmSW52aXNpYmxlVGltZXM7RidGOUY7Rj5GQEZCRkRGRkZIRmhuRmpuLUYsNiVRInRGJ0YvRjJGOUY5RjlGYG8vJTFzdXBlcnNjcmlwdHNoaWZ0R1EiMEYnRmBvLyUubGluZXRoaWNrbmVzc0dRIjFGJy8lK2Rlbm9tYWxpZ25HUSdjZW50ZXJGJy8lKW51bWFsaWduR0ZicC8lKWJldmVsbGVkR0Y9LUY2Ni1RJyZwbHVzO0YnRjlGO0Y+RkBGQkZERkZGSC9GS1EsMC4yMjIyMjIyZW1GJy9GTkZbcS1GUDYoLUZTNiUtRiM2JkZXRmVuLUZcbzYkLUYjNiUtRjY2LVEqJnVtaW51czA7RidGOUY7Rj5GQEZCRkRGRkZIRmpwRlxxRmdvRjlGOUY5RmBvRmpvRmBvRl1wRmBwRmNwRmVwRmdwLUZQNigtRmFvNiRGX3BGOS1GYW82JFEiNEYnRjlGXXBGYHBGY3BGZXAtRjY2LVEoJm1pbnVzO0YnRjlGO0Y+RkBGQkZERkZGSEZqcEZccS1GUDYoRlVGYG9GXXBGYHBGY3BGZXBGYXItRlA2KEZhcUZgb0ZdcEZgcEZjcEZlcEZncC1GIzYmLUZcbzYkLUYjNigtRlA2KC1GYW82JFEiM0YnRjlGYG9GXXBGYHBGY3BGZXBGYXJGVUZhckZhcUY5RjlGZG9GZ29GOUZncC1GUDYoLUZTNiVGZ29GYG9Gam9GYG9GXXBGYHBGY3BGZXBGOQ==">LV9JLFR5cGVzZXR0aW5nRzYkJSpwcm90ZWN0ZWRHSShfc3lzbGliRzYiSSxtcHJpbnRzbGFzaEdGKDYkNyM+SSNBMUdGKCwwKiYjIiIiIiIjRjEpLUklZnJhY0dGJTYjLCQqJkYyRjFJInRHRihGMUYxRjJGMUYxKiZGMEYxKS1GNTYjLCRGOSEiIkYyRjFGMSNGMSIiJUYxKiZGMEYxRjRGMUY/KiZGMEYxRjxGMUY/KiYsKCMiIiRGMkYxRjRGP0Y8Rj9GMUY5RjFGMSomRjBGMSlGOUYyRjFGMTcjRi4=</Equation></Text-field>
</Output>
</Group>
<Group labelreference="L131" drawlabel="true">
<Input>
<Text-field prompt="&gt; " style="Maple Input" layout="Normal"></Text-field>
</Input>
</Group>
</Worksheet>